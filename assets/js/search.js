
var documents = [{
    "id": 0,
    "url": "https://nipunbatra.github.io/404.html",
    "title": "",
    "body": " 404 Page not found :(  The requested page could not be found. "
    }, {
    "id": 1,
    "url": "https://nipunbatra.github.io/categories/",
    "title": "Tags",
    "body": "Contents: {% if site. categories. size &gt; 0 %} {% for category in site. categories %} {% capture category_name %}{{ category | first }}{% endcapture %} {{ category_name }}{% endfor %}{% endif %} {% for category in site. categories %}  {% capture category_name %}{{ category | first }}{% endcapture %} &lt;h3 id = {{ category_name }} &gt;&lt;i class= fas fa-tags category-tags-icon &gt;&lt;/i&gt;&lt;/i&gt; {{ category_name }}&lt;/h3&gt;&lt;a name= {{ category_name | slugize }} &gt;&lt;/a&gt;{% for post in site. categories[category_name] %}{%- assign date_format = site. minima. date_format | default:  %b %-d, %Y  -%}&lt;article class= archive-item &gt; &lt;p class= post-meta post-meta-title &gt;&lt;a class= page-meta  href= {{ site. baseurl }}{{ post. url }} &gt;{{post. title}}&lt;/a&gt; • {{ post. date | date: date_format }}&lt;/p&gt;&lt;/article&gt;{% endfor %} {% endfor %}"
    }, {
    "id": 2,
    "url": "https://nipunbatra.github.io/images/copied_from_nb/",
    "title": "",
    "body": "WarningDo not manually save images into this folder. This is used by GitHub Actions to automatically copy images.  Any images you save into this folder could be deleted at build time. "
    }, {
    "id": 3,
    "url": "https://nipunbatra.github.io/ml/2020/02/20/bayesian-linear-regression.html",
    "title": "Bayesian Linear Regression",
    "body": "2020/02/20 -                 import numpy as npimport pandas as pdimport matplotlib. pyplot as plt%matplotlib inline          x = np. linspace(-1, 1, 50). reshape(-1, 1)          y = 5*x + 4 noise = (np. abs(x. flatten())*np. random. randn(len(x))). reshape(-1,1)y = y + noise          plt. scatter(x, y)plt. plot(x, 5*x + 4, &#39;k&#39;)  [&lt;matplotlib. lines. Line2D at 0x115c28cd0&gt;]        from scipy. stats import multivariate_normalfrom matplotlib import cmcov = np. array([[ 1 , 0], [0, 1]])var = multivariate_normal(mean=[0,0], cov=cov)x_grid, y_grid = np. mgrid[-1:1:. 01, -1:1:. 01]pos = np. dstack((x_grid, y_grid))z = var. pdf(pos)plt. contourf(x_grid, y_grid, z)plt. gca(). set_aspect(&#39;equal&#39;)plt. xlabel(r&quot;$\theta_0$&quot;)plt. ylabel(r&quot;$\theta_1$&quot;)plt. title(r&quot;Prior distribution of $\theta = f(\mu, \Sigma)$&quot;)plt. colorbar()  &lt;matplotlib. colorbar. Colorbar at 0x1a18423950&gt;  $$\prod_{i=1}^{n} \frac{1}{\sqrt{2 \pi \sigma^{2}}} e^{-\frac{(y_{i}-\hat{y}_{i})^{2}}{2 \sigma^{2}}}$$Sample from prior&#182;:       n_samples = 20for n in range(n_samples):  theta_0_s, theta_1_s = var. rvs()  plt. plot(x, theta_1_s*x + theta_0_s, color=&#39;k&#39;,alpha=0. 2)plt. scatter(x, y)  &lt;matplotlib. collections. PathCollection at 0x1a18598fd0&gt;  Likelihood of theta&#182;:       def likelihood(theta_0, theta_1, x, y, sigma):  s = 0  x_plus_1 = np. hstack((np. ones_like(x), x))  for i in range(len(x)):    y_i_hat = x_plus_1[i, :]@np. array([theta_0, theta_1])    s += (y[i,:]-y_i_hat)**2      return np. exp(-s/(2*sigma*sigma))/np. sqrt(2*np. pi*sigma*sigma)          likelihood(-1, 1, x, y, 4)  array([1. 00683395e-22])        x_grid_2, y_grid_2 = np. mgrid[0:8:. 1, 0:8:. 1]li = np. zeros_like(x_grid_2)for i in range(x_grid_2. shape[0]):  for j in range(x_grid_2. shape[1]):    li[i, j] = likelihood(x_grid_2[i, j], y_grid_2[i, j], x, y, 4)              plt. contourf(x_grid_2, y_grid_2, li)plt. gca(). set_aspect(&#39;equal&#39;)plt. xlabel(r&quot;$\theta_0$&quot;)plt. ylabel(r&quot;$\theta_1$&quot;)plt. colorbar()plt. scatter(4, 5, s=200, marker=&#39;*&#39;, color=&#39;r&#39;)plt. title(r&quot;Likelihood as a function of ($\theta_0, \theta_1$)&quot;)  Text(0. 5, 1. 0, &#39;Likelihood as a function of ($\\theta_0, \\theta_1$)&#39;)  Likelihood of $\sigma^2$&#182;:       x_plus_1 = np. hstack((np. ones_like(x), x))theta_mle = np. linalg. inv(x_plus_1. T@x_plus_1)@(x_plus_1. T@y)sigma_2_mle = np. linalg. norm(y - x_plus_1@theta_mle)**2sigma_mle = np. sqrt(sigma_2_mle)sigma_mle  4. 128685902124939  Posterior&#182;: $$\begin{aligned}p(\boldsymbol{\theta} | \mathcal{X}, \mathcal{Y}) &amp;=\mathcal{N}\left(\boldsymbol{\theta} | \boldsymbol{m}_{N}, \boldsymbol{S}_{N}\right) \\\boldsymbol{S}_{N} &amp;=\left(\boldsymbol{S}_{0}^{-1}+\sigma^{-2} \boldsymbol{\Phi}^{\top} \boldsymbol{\Phi}\right)^{-1} \\\boldsymbol{m}_{N} &amp;=\boldsymbol{S}_{N}\left(\boldsymbol{S}_{0}^{-1} \boldsymbol{m}_{0}+\sigma^{-2} \boldsymbol{\Phi}^{\top} \boldsymbol{y}\right)\end{aligned}$$      S0 = np. array([[ 1 , 0], [0, 1]])M0 = np. array([0, 0])SN = np. linalg. inv(np. linalg. inv(S0) + (sigma_mle**-2)*x_plus_1. T@x_plus_1)MN = SN@(np. linalg. inv(S0)@M0 + (sigma_mle**-2)*(x_plus_1. T@y). squeeze())          MN, SN  (array([2. 97803341, 2. 54277597]), array([[2. 54243881e-01, 2. 97285330e-17],    [2. 97285330e-17, 4. 95625685e-01]]))        from scipy. stats import multivariate_normalfrom matplotlib import cmcov = np. array([[ 1 , 0], [0, 1]])var_pos = multivariate_normal(mean=MN, cov=SN)x_grid, y_grid = np. mgrid[0:8:. 1, 0:8:. 1]pos = np. dstack((x_grid, y_grid))z = var_pos. pdf(pos)plt. contourf(x_grid, y_grid, z)plt. gca(). set_aspect(&#39;equal&#39;)plt. xlabel(r&quot;$\theta_0$&quot;)plt. ylabel(r&quot;$\theta_1$&quot;)plt. title(r&quot;Posterior distribution of $\theta = f(\mu, \Sigma)$&quot;)plt. scatter(4, 5, s=200, marker=&#39;*&#39;, color=&#39;r&#39;, label=&#39;MLE&#39;)plt. scatter(MN[0], MN[1], s=100, marker=&#39;^&#39;, color=&#39;black&#39;, label=&#39;MAP&#39;)plt. colorbar()plt. legend()plt. savefig(&quot;. . /images/blr-map. png&quot;)    Sample from posterior       n_samples = 20for n in range(n_samples):  theta_0_s, theta_1_s = var_pos. rvs()  plt. plot(x, theta_1_s*x + theta_0_s, color=&#39;k&#39;,alpha=0. 2)plt. scatter(x, y)  &lt;matplotlib. collections. PathCollection at 0x1a18e7dd10&gt;  Posterior predictions&#182;: $$\begin{aligned}p\left(y_{*} | \mathcal{X}, \mathcal{Y}, \boldsymbol{x}_{*}\right) &amp;=\int p\left(y_{*} | \boldsymbol{x}_{*}, \boldsymbol{\theta}\right) p(\boldsymbol{\theta} | \mathcal{X}, \mathcal{Y}) \mathrm{d} \boldsymbol{\theta} \\&amp;=\int \mathcal{N}\left(y_{*} | \boldsymbol{\phi}^{\top}\left(\boldsymbol{x}_{*}\right) \boldsymbol{\theta}, \sigma^{2}\right) \mathcal{N}\left(\boldsymbol{\theta} | \boldsymbol{m}_{N}, \boldsymbol{S}_{N}\right) \mathrm{d} \boldsymbol{\theta} \\&amp;=\mathcal{N}\left(y_{*} | \boldsymbol{\phi}^{\top}\left(\boldsymbol{x}_{*}\right) \boldsymbol{m}_{N}, \boldsymbol{\phi}^{\top}\left(\boldsymbol{x}_{*}\right) \boldsymbol{S}_{N} \boldsymbol{\phi}\left(\boldsymbol{x}_{*}\right)+\sigma^{2}\right)\end{aligned}$$For a point $x*$ Predictive mean = $X^Tm_N$ Predictive variance = $X^TS_NX + \sigma^2$       x_plus_1. T. shape, SN. shape, x_plus_1. shape  ((2, 50), (2, 2), (50, 2))        pred_var = x_plus_1@SN@x_plus_1. Tpred_var. shape  (50, 50)        ## Marginalindividual_var = pred_var. diagonal()          y_hat_map = x_plus_1@MNplt. plot(x, y_hat_map, color=&#39;black&#39;)plt. fill_between(x. flatten(), y_hat_map-individual_var, y_hat_map+individual_var, alpha=0. 2, color=&#39;black&#39;)plt. scatter(x, y)  &lt;matplotlib. collections. PathCollection at 0x1a1881e450&gt;  "
    }, {
    "id": 4,
    "url": "https://nipunbatra.github.io/markdown/2020/01/14/test-markdown.html",
    "title": "Example Markdown Post",
    "body": "2020/01/14 - Basic setup: Jekyll requires blog post files to be named according to the following format: YEAR-MONTH-DAY-filename. md Where YEAR is a four-digit number, MONTH and DAY are both two-digit numbers, and filename is whatever file name you choose, to remind yourself what this post is about. . md is the file extension for markdown files. The first line of the file should start with a single hash character, then a space, then your title. This is how you create a “level 1 heading” in markdown. Then you can create level 2, 3, etc headings as you wish but repeating the hash character, such as you see in the line ## File names above. Basic formatting: You can use italics, bold, code font text, and create links. Here’s a footnote 1. Here’s a horizontal rule: Lists: Here’s a list:  item 1 item 2And a numbered list:  item 1 item 2Boxes and stuff:  This is a quotation    You can include alert boxes…and…    You can include info boxesImages: Code: General preformatted text: # Do a thingdo_thing()Python code and output: # Prints '2'print(1+1)2Tables:       Column 1   Column 2         A thing   Another thing   Tweetcards: Altair 4. 0 is released! https://t. co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t. co/roXmzcsT58 . . . read on for some highlights. pic. twitter. com/vWJ0ZveKbZ &mdash; Jake VanderPlas (@jakevdp) December 11, 2019Footnotes:       This is the footnote.  &#8617;    "
    }, {
    "id": 5,
    "url": "https://nipunbatra.github.io/ml/2019/08/20/Gaussian-Processes.html",
    "title": "Gaussian Processes",
    "body": "2019/08/20 -           An example&#182;: Let us look at the GIF above. It shows a non-linear fit with uncertainty on a set of points in the 2d space. The uncertainty is shown by the gray shadowed region. The animation shows how the fit and the uncertainty varies as we keep adding more points (shown as big circles). As expected, as more points are added, the uncertainty of the fit in the vicinity of the added points reduces. This is an example of Gaussian Processes (GP) regression in play. Introduction&#182;: There exist some great online resources for Gaussian Processes (GPs) including an excellent recent Distill. Pub article. This blog post is an attempt with a programatic flavour. In this notebook, we will build the intuition and learn some basics of GPs. This notebook is heavily inspired by the awesome tutorial by Richard Turner. Here is the link to the slides and video. Lectures videos and notes from Nando De Freitas' course are an amazing resource for GPs (and anything ML!). Some imports&#182;:       import numpy as npimport matplotlib. pyplot as pltimport warningswarnings. filterwarnings(&#39;ignore&#39;)%matplotlib inline    A function to make the Matplotlib plots prettier&#182;:       SPINE_COLOR = &#39;gray&#39;def format_axes(ax):  for spine in [&#39;top&#39;, &#39;right&#39;]:    ax. spines[spine]. set_visible(False)  for spine in [&#39;left&#39;, &#39;bottom&#39;]:    ax. spines[spine]. set_color(SPINE_COLOR)    ax. spines[spine]. set_linewidth(0. 5)  ax. xaxis. set_ticks_position(&#39;bottom&#39;)  ax. yaxis. set_ticks_position(&#39;left&#39;)  for axis in [ax. xaxis, ax. yaxis]:    axis. set_tick_params(direction=&#39;out&#39;, color=SPINE_COLOR)  return ax    One dimensional Gaussian/Normal&#182;: We will start the discussion with 1d Gaussians. Let us write some simple code to generate/sample data from $\mathcal{N}(\mu=0, \sigma=1)$       one_dim_normal_data = np. random. normal(0, 1, size=10000)    Let us now visualise the data in a 1d space using scatter plot       plt. scatter(one_dim_normal_data, np. zeros_like(one_dim_normal_data), alpha=0. 2, c=&#39;gray&#39;, edgecolors=&#39;k&#39;, marker=&#39;o&#39;)format_axes(plt. gca())  &lt;matplotlib. axes. _subplots. AxesSubplot at 0x7fb2f0be5b00&gt;  As we would expect, there are a lot of samples close to zero (mean) and as we go further away from zero, the number of samples keeps reducing. We can also visualise the same phenomenon using a normed histogram shown below.       plt. hist(one_dim_normal_data, density=True, bins=20, color=&#39;gray&#39;)format_axes(plt. gca())  &lt;matplotlib. axes. _subplots. AxesSubplot at 0x7fb2f0813588&gt;  We can notice that there is a high probability of drawing samples close to the mean and the probability is low far from the mean. However, since histograms come with their own set of caveats, let us use kernel desnity estimation for obtaining the probability density of 1d Gaussian.       from sklearn. neighbors import KernelDensityx_d = np. linspace(-4, 4, 100)# instantiate and fit the KDE modelkde = KernelDensity(bandwidth=1. 0, kernel=&#39;gaussian&#39;)kde. fit(one_dim_normal_data[:, None])# score_samples returns the log of the probability densitylogprob = kde. score_samples(x_d[:, None])plt. fill_between(x_d, np. exp(logprob), alpha=0. 2, color=&#39;gray&#39;)plt. plot(one_dim_normal_data, np. full_like(one_dim_normal_data, -0. 01), &#39;|k&#39;, markeredgewidth=0. 1)format_axes(plt. gca())  &lt;matplotlib. axes. _subplots. AxesSubplot at 0x7fb2ee1f8c88&gt;  We can now see a smoother version of the histogram and can again verify the properties of 1D Gaussian. Let us now vary the variance of 1D Gaussian and make the same plots to enhance our understanding of the concept.       fig, ax = plt. subplots(ncols=3, sharey=True, figsize=(9, 3))x_d = np. linspace(-6, 6, 400)for i, var in enumerate([0. 5, 1, 2]):  one_dim_normal_data = np. random. normal(0, var, size=10000)  kde = KernelDensity(bandwidth=1. 0, kernel=&#39;gaussian&#39;)  kde. fit(one_dim_normal_data[:, None])  # score_samples returns the log of the probability density  logprob = kde. score_samples(x_d[:, None])  ax[i]. fill_between(x_d, np. exp(logprob), alpha=0. 2, color=&#39;gray&#39;)  ax[i]. plot(one_dim_normal_data, np. full_like(one_dim_normal_data, -0. 01), &#39;|k&#39;, markeredgewidth=0. 1)  format_axes(ax[i])  ax[i]. set_title(f&quot;Variance = {var}&quot;)    We can see that how increasing the variance makes the data more spread. Bi-variate Gaussian&#182;: Having discussed the case of 1d Gaussian, now let us move to multivariate Gaussians. As a special case, let us first consider bi-variate or 2d Gaussian. It's parameters are the mean vector which will have 2 elements and a covariance matrix. We can write the distribution as:$$\begin{pmatrix} X_1 \\ X_2\end{pmatrix} \sim \mathcal{N} \left( \begin{pmatrix} \mu_1 \\ \mu_2\end{pmatrix} , \begin{pmatrix} a &amp; \rho \\ \rho &amp; b\end{pmatrix} \right)$$ where $\mu_1$, $\mu_2$ are the means for $X_1$ and $X_2$ respectively; $a$ is the standard deviation for $X_1$, $b$ is the standard deviation for $X_2$ and $\rho$ is the correlation between $X_1$ and $X_2$ Let us now draw some data from: $$\begin{pmatrix} X_1 \\ X_2\end{pmatrix} \sim \mathcal{N} \left( \begin{pmatrix} 0 \\ 0\end{pmatrix} , \begin{pmatrix} 1 &amp; 0. 7 \\ 0. 7 &amp; 1\end{pmatrix} \right)$$       data = np. random. multivariate_normal(mean = np. array([0, 0]), cov = np. array([[1, 0. 7], [0. 7, 1]]), size=(10000, ))          plt. scatter(data[:, 0], data[:, 1], alpha=0. 05,c=&#39;gray&#39;)plt. axhline(0, color=&#39;k&#39;, lw=0. 2)plt. axvline(0, color=&#39;k&#39;, lw=0. 2)plt. xlabel(r&quot;$X_1$&quot;)plt. ylabel(r&quot;$X_2$&quot;)format_axes(plt. gca())  &lt;matplotlib. axes. _subplots. AxesSubplot at 0x7fb2edfeb780&gt;  We can see from the plot above that the data is distributed around mean [0, 0]. We can also see the positive correlation between $X_1$ and $X_2$ Marginalisation for bivariate Gaussian&#182;: Let us look into an interesting plot provided by Seaborn.       import pandas as pddata_df = pd. DataFrame(data, columns=[r&#39;$X_1$&#39;,r&#39;$X_2$&#39;])          import seaborn as snsg = sns. jointplot(x= r&#39;$X_1$&#39;, y=r&#39;$X_2$&#39;, data=data_df, kind=&quot;reg&quot;,color=&#39;gray&#39;)    The central plot is exactly the same as the scatter plot we made earlier. But, we see two additional 1d KDE plots at the top and the right. What do these tell us? These tell us the marginal 1d distributions of $X_1$ and $X_2$. The marginal distribution of $X_1$ is the distribution of $X_1$ considering all values of $X_2$ and vice versa. One of the interesting properties of Gaussian distributions is that the marginal distribution of a Gaussian is also a Gaussian distribution. MathematicalMonk on Youtube has a great set of lectures on this topic that I would highly recommend! What would you expect the marginal distribution of $X_1$ to look like? No prizes for guessing. Given $$\begin{pmatrix} X_1 \\ X_2\end{pmatrix} \sim \mathcal{N} \left( \begin{pmatrix} \mu_1 \\ \mu_2\end{pmatrix} , \begin{pmatrix} a &amp; \rho \\ \rho &amp; b\end{pmatrix} \right)$$ we have the marginal distribution of:$$X_1 \sim \mathcal{N}(\mu_1, a)$$and $$X_2 \sim \mathcal{N}(\mu_2, b)$$       def plot_jointplot_2d(a, b, rho):  data = np. random. multivariate_normal(mean = np. array([0, 0]), cov = np. array([[a, rho], [rho, b]]), size=(10000, ))  data_df = pd. DataFrame(data, columns=[r&#39;$X_1$&#39;,r&#39;$X_2$&#39;])  g = sns. jointplot(x= r&#39;$X_1$&#39;, y=r&#39;$X_2$&#39;, data=data_df, kind=&quot;reg&quot;,color=&#39;gray&#39;)    Ok, let us know try to plot a few jointplots for different covariance matrices. We would be passing in the values of $a$, $b$ and $\rho$ which would make up the covariance matrix as: \begin{pmatrix} a &amp; \rho \\ \rho &amp; b\end{pmatrix} We would make these plots for mean zero.       plot_jointplot_2d(1, 1, -0. 7)    In the plot above, for $a=1$, $b=1$ and $\rho=0. 7$ we can see the negative correlation (but high) between $X_1$ and $X_2$. Let us now increase the variance in $X_1$ and keep all other paramaters constant.       plot_jointplot_2d(2, 1, -0. 7)    One can see from the plot above that the variance in $X_1$ is much higher now and the plot extends from -6 to +6 for $X_1$ while earlier it was restricted from -4 to 4.       plot_jointplot_2d(1, 1, 0. 0)    One can see from the plot above that the correlation between $X_1$ and $X_2$ is zero. Surface plots for bi-variate Gaussian&#182;: We will now look into surface plots for bi-variate Gaussian. This is yet another way to plot and understand Gaussian distributions. I borrow code from an excellent tuorial on plotting bivariate Gaussians.       from scipy. stats import multivariate_normalfrom mpl_toolkits. mplot3d import Axes3Dfrom matplotlib import cmdef make_pdf_2d_gaussian(mu, sigma):  N = 60  X = np. linspace(-3, 3, N)  Y = np. linspace(-3, 4, N)  X, Y = np. meshgrid(X, Y)  # Pack X and Y into a single 3-dimensional array  pos = np. empty(X. shape + (2,))  pos[:, :, 0] = X  pos[:, :, 1] = Y  F = multivariate_normal(mu, sigma)  Z = F. pdf(pos)  # Create a surface plot and projected filled contour plot under it.   fig = plt. figure()  ax = fig. gca(projection=&#39;3d&#39;)  ax. plot_surface(X, Y, Z, rstride=3, cstride=3, linewidth=1, antialiased=True,          cmap=cm. Greys)    ax. set_xlabel(r&quot;$X_1$&quot;)  ax. set_ylabel(r&quot;$X_2$&quot;)  ax. set_zlabel(&quot;PDF&quot;)  cset = ax. contourf(X, Y, Z, zdir=&#39;z&#39;, offset=-0. 15, cmap=cm. Greys)  # Adjust the limits, ticks and view angle  ax. set_zlim(-0. 15,0. 25)  ax. set_zticks(np. linspace(0,0. 2,5))  ax. view_init(27, -15)  ax. set_title(f&#39;$\mu$ = {mu}\n $\Sigma$ = {sigma}&#39;)          mu = np. array([0. , 0. ])sigma = np. array([[ 1. , -0. 5], [-0. 5, 1]])make_pdf_2d_gaussian(mu, sigma)    From the plot above, we can see the surface plot showing the probability density function for the Gaussian with mean \begin{pmatrix} 0 \\ 0\end{pmatrix} and covariance matrix: \begin{pmatrix} 1 &amp; -0. 5 \\ -0. 5 &amp; 1\end{pmatrix} It can be seen that the probability peaks arounds $X_1=0$ and $X_2=0$. The bottom plot shows the same concept using contour plots which we will heavily use from now on. The different circles in the bottom contour plot denote the loci of same probability density. Since the contour plot requires a lesser dimension, it will be easier to use in our further analysis. Also, from the contour plots, we can see the correlation between $X_1$ and $X_2$.       mu = np. array([0. , 0. ])sigma = np. array([[ 1. , 0], [0, 1]])make_pdf_2d_gaussian(mu, sigma)    In the plot above, we can see that $X_1$ and $X_2$ are not correlated. Contour plots for 2D Gaussians&#182;: Having seen the relationship between the surface plots and the contour plots, we will now exclusively focus on the contour plots. Here is a simple function to generate the contour plot for 2g gaussian with mean and covariance as the arguments.       def plot_2d_contour_pdf(mu, sigma):  X = np. linspace(-3, 3, 60)  Y = np. linspace(-3, 4, 60)  X, Y = np. meshgrid(X, Y)  # Pack X and Y into a single 3-dimensional array  pos = np. empty(X. shape + (2,))  pos[:, :, 0] = X  pos[:, :, 1] = Y  F = multivariate_normal(mu, sigma)  Z = F. pdf(pos)  plt. xlabel(r&quot;$X_1$&quot;)  plt. ylabel(r&quot;$X_2$&quot;)    plt. title(f&#39;$\mu$ = {mu}\n $\Sigma$ = {sigma}&#39;)  plt. contourf(X, Y, Z, zdir=&#39;z&#39;, offset=-0. 15, cmap=cm. Greys)  plt. colorbar()  format_axes(plt. gca())          mu = np. array([0. , 0. ])sigma = np. array([[ 1. , 0. 5], [0. 5, 1. ]])plot_2d_contour_pdf(mu, sigma)  /home/nipunbatra-pc/anaconda3/lib/python3. 7/site-packages/matplotlib/contour. py:1000: UserWarning: The following kwargs were not used by contour: &#39;zdir&#39;, &#39;offset&#39; s)  The plot above shows the contour plot for 2d gaussian with mean [0, 0] and covariance [[ 1. , 0. 5], [0. 5, 1. ]]. We can see the correlation between $X_1$ and $X_2$ Sample from 2d gaussian and visualising it on XY plane&#182;: We will now sample a point from a 2d Gaussian and describe a new way of visualising it.  The left most plot shows the covariance matrix. The middle plot shows the contour plot. The dark point marked in the contour plot is a sampled point (at random) from this 2d Gaussian distribution. The right most plot is an alternative representation of the sampled point. The x-axis corresponds to the labels $X_1$ and $X_2$ and the corresponding y-axis are the coordinates of the point in the $X_1$, $X_2$ dimension shown in the contour plot. We will now write a function to generate a random sample from a 2d gaussian given it's mean and covariance matrix.       def plot_2d_contour_pdf_dimensions(mu, sigma, random_num):  fig, ax = plt. subplots(ncols=3, figsize=(12, 4))  X = np. linspace(-3, 3, 60)  Y = np. linspace(-3, 3, 60)  X, Y = np. meshgrid(X, Y)  # Pack X and Y into a single 3-dimensional array  pos = np. empty(X. shape + (2,))  pos[:, :, 0] = X  pos[:, :, 1] = Y  F = multivariate_normal(mu, sigma)  Z = F. pdf(pos)  random_point = F. rvs(random_state=random_num)    sns. heatmap(sigma, ax=ax[0], annot=True)  ax[1]. contour(X, Y, Z, cmap=cm. Greys)  ax[1]. scatter(random_point[0], random_point[1], color=&#39;k&#39;,s=100)  ax[1]. set_xlabel(r&quot;$X_1$&quot;)  ax[1]. set_ylabel(r&quot;$X_2$&quot;)    data_array = pd. Series(random_point, index=[&#39;X1&#39;,&#39;X2&#39;])  data_array. plot(ax=ax[2], kind=&#39;line&#39;, marker=&#39;o&#39;,color=&#39;k&#39;)  plt. xticks(np. arange(len(data_array. index)), data_array. index. values)  ax[2]. set_ylim(-3, 3)    format_axes(ax[0])  format_axes(ax[1])  format_axes(ax[2])  ax[0]. set_title(&quot;Covariance Matrix&quot;)  ax[1]. set_title(&quot;Contour of pdf&quot;)  ax[2]. set_title(&quot;Visualising the point&quot;)  plt. suptitle(f&quot;Random state = {random_num}&quot;, y=1. 1)  plt. tight_layout()  import os  if not os. path. exists(&quot;images&quot;):    os. makedirs(&quot;images&quot;)  if not os. path. exists(f&quot;images/{sigma[0, 1]}&quot;):    os. makedirs(f&quot;images/{sigma[0, 1]}&quot;)  plt. savefig(f&quot;images/{sigma[0, 1]}/{random_num}. jpg&quot;, bbox_inches=&quot;tight&quot;)  plt. close()    We will now create 20 such samples and animate them       for i in range(20):  plot_2d_contour_pdf_dimensions( mu, np. array([[ 1. , 0. 1], [0. 1, 1. ]]), i)          !convert -delay 20 -loop 0 images/0. 1/*. jpg sigma-0-1. gif     Since the correlation between the two variables $X_1$ and $X_2$ was low (0. 1), we can the see that rightmost plot jumping a lot, i. e. to say that the values of $X_1$ and $X_2$ are not tighly constrained to move together.       for i in range(20):  plot_2d_contour_pdf_dimensions( mu, np. array([[ 1. , 0. 7], [0. 7, 1. ]]), i)          !convert -delay 20 -loop 0 images/0. 7/*. jpg sigma-0-7. gif     The above GIF shows the same plot/animation for the 2d Gaussian where the correlation between the two variables is high (0. 7). Thus, we can see that the two variables tend to move up and down together. Conditional Bivariate Distribution&#182;: All excellent till now. Now, let us move to the case in which some variable's values are known. We would then look to find the distribution of the other variables conditional on the value of the known variable. I borrow some text from Wikipedia on the subject. $$\begin{pmatrix} X_1 \\ X_2\end{pmatrix} \sim \mathcal{N} \left( \begin{pmatrix} 0 \\ 0\end{pmatrix} , \begin{pmatrix} 1 &amp; \rho \\ \rho &amp; 1\end{pmatrix} \right)$$The conditional expectation of $X_2$ given $X_1$ is: $\operatorname{E}(X_2 \mid X_1=x_1)= \rho x_1 $ and the conditional variance is: $\operatorname{var}(X_2 \mid X_1 = x_1) = 1-\rho^2$ So, the question now is: suppose we fix $X_1 = 1$, what is the distribution of $X_2$. Again, Gaussians are amazing - the conditional distributionon is again a Gaussian. Let us make some plots to understand better. The following plots would be showing the distribution of $X_2$ with fixed $X_1$       def plot_2d_contour_pdf_dimensions_fixed_x1(sigma, random_num, x1 = 1):  mu = np. zeros(2)  fig, ax = plt. subplots(ncols=3, figsize=(12, 4))  X = np. linspace(-3, 3, 60)  Y = np. linspace(-3, 3, 60)  X, Y = np. meshgrid(X, Y)  # Pack X and Y into a single 3-dimensional array  pos = np. empty(X. shape + (2,))  pos[:, :, 0] = X  pos[:, :, 1] = Y  F = multivariate_normal(mu, sigma)  Z = F. pdf(pos)    rho = sigma[0, 1]  F_cond_x1 = multivariate_normal(rho*x1, 1-rho**2)  random_point_x2 = F_cond_x1. rvs(random_state=random_num)  sns. heatmap(sigma, ax=ax[0], annot=True)  ax[1]. contour(X, Y, Z, cmap=cm. Greys)  ax[1]. scatter(x1, random_point_x2, color=&#39;k&#39;,s=100)  ax[1]. set_xlabel(r&quot;$X_1$&quot;)  ax[1]. set_ylabel(r&quot;$X_2$&quot;)    data_array = pd. Series([x1, random_point_x2], index=[&#39;X1&#39;,&#39;X2&#39;])  data_array. plot(ax=ax[2], kind=&#39;line&#39;, color=&#39;k&#39;)  ax[2]. scatter(x=0, y=x1, color=&#39;red&#39;, s=100)  ax[2]. scatter(x=1, y=random_point_x2, color=&#39;k&#39;, s=100)    plt. xticks(np. arange(len(data_array. index)), data_array. index. values)  ax[2]. set_ylim(-3, 3)  format_axes(ax[0])  format_axes(ax[1])  format_axes(ax[2])  ax[0]. set_title(&quot;Covariance Matrix&quot;)  ax[1]. set_title(&quot;Contour of pdf&quot;)  ax[2]. set_title(&quot;Visualising the point&quot;)  plt. suptitle(f&quot;Random state = {random_num}&quot;, y=1. 1)  plt. tight_layout()  import os  if not os. path. exists(&quot;images/conditional/&quot;):    os. makedirs(&quot;images/conditional/&quot;)  if not os. path. exists(f&quot;images/conditional/{sigma[0, 1]}&quot;):    os. makedirs(f&quot;images/conditional/{sigma[0, 1]}&quot;)  plt. savefig(f&quot;images/conditional/{sigma[0, 1]}/{random_num}. jpg&quot;, bbox_inches=&quot;tight&quot;)  plt. close()          for i in range(20):  plot_2d_contour_pdf_dimensions_fixed_x1(np. array([[ 1. , 0. 1], [0. 1, 1. ]]), i)          !convert -delay 20 -loop 0 images/conditional/0. 1/*. jpg conditional-sigma-0-1. gif     The above animation shows the movement of $X_2$ with $X_1=1$. The $X_1=1$ is shown in red in the righmost plot. In the middle plot, we can confirm that the movement is only in the $X_2$ dimension. Further, since the correlation between $X_1$ and $X_2$ is weak, the righmost plot seems to wiggle or jump a lot!       for i in range(20):  plot_2d_contour_pdf_dimensions_fixed_x1(np. array([[ 1. , 0. 7], [0. 7, 1. ]]), i)          !convert -delay 20 -loop 0 images/conditional/0. 7/*. jpg conditional-sigma-0-7. gif     In the plot above, we repeat the same p|rocedure but with a covariance matrix having a much higher correlation between $X_1$ and $X_2$. From the righmost plot, we can clearly see that the jumps in $X2$ are far lesser. This is expected, since the two variables are correlated! Visualising the same procedure for 5 dimensional Gaussian&#182;: We will now repeat the same procedure we did for 2d case in 5 dimensions.       covariance_5d = np. array([[1, 0. 9, 0. 8, 0. 6, 0. 4],             [0. 9, 1, 0. 9, 0. 8, 0. 6],             [0. 8, 0. 9, 1, 0. 9, 0. 8],             [0. 6, 0. 8, 0. 9, 1, 0. 9],             [0. 4, 0. 6, 0. 8, 0. 9, 1]])          def plot_5d_contour_pdf_dimensions(cov, random_num):  fig, ax = plt. subplots(ncols=2, figsize=(6, 3))  mu = np. zeros(5)  F = multivariate_normal(mu, cov)  random_point = F. rvs(random_state=random_num)    sns. heatmap(cov, ax=ax[0], annot=True)      data_array = pd. Series(random_point, index=[&#39;X1&#39;,&#39;X2&#39;,&#39;X3&#39;,&#39;X4&#39;, &#39;X5&#39;])  data_array. plot(ax=ax[1], kind=&#39;line&#39;, marker=&#39;o&#39;,color=&#39;k&#39;)  plt. xticks(np. arange(len(data_array. index)), data_array. index. values)  ax[1]. set_ylim(-3, 3)  for i in range(2):    format_axes(ax[i])    ax[0]. set_title(&quot;Covariance Matrix&quot;)  ax[-1]. set_title(&quot;Visualising the point&quot;)  plt. suptitle(f&quot;Random state = {random_num}&quot;, y=1. 1)  plt. tight_layout()  import os  if not os. path. exists(&quot;images/5d/&quot;):    os. makedirs(&quot;images/5d&quot;)    plt. savefig(f&quot;images/5d/{random_num}. jpg&quot;, bbox_inches=&quot;tight&quot;)  plt. close()          plot_5d_contour_pdf_dimensions(covariance_5d, 2)          for i in range(20):  plot_5d_contour_pdf_dimensions(covariance_5d, i)          !convert -delay 20 -loop 0 images/5d/*. jpg 5d. gif     From the visualisation above we can see that: since X1 and X2 are highly correlated, they move up and down togetherbut, X1 and X5 have low correlation, thus, they can seem to wiggle almost independently of each other. We are now getting somewhere. If the correlation between the variables is very high, we will get a smooth curve joining them. Right? Almost getting to the point where we can draw the introductory plot shown at the top of the post. Conditional Multivariate Distribution&#182;: Ok, now let us draw the conditional distribution over this higher 5d space. We will fix the values of some of the variables and see the distribution of the others. Borrowing from Wikipedia If $N$-dimensional $x$ is partitioned as follows $$\mathbf{x}=\begin{bmatrix} \mathbf{x}_A \\ \mathbf{x}_B\end{bmatrix}\text{ with sizes }\begin{bmatrix} q \times 1 \\ (N-q) \times 1 \end{bmatrix}$$and accordingly $μ$ and $Σ$ are partitioned as follows $$\boldsymbol\mu=\begin{bmatrix} \boldsymbol\mu_A \\ \boldsymbol\mu_B\end{bmatrix}\text{ with sizes }\begin{bmatrix} q \times 1 \\ (N-q) \times 1 \end{bmatrix}$$$$\boldsymbol\Sigma=\begin{bmatrix} \boldsymbol\Sigma_{AA} &amp; \boldsymbol\Sigma_{AB} \\ \boldsymbol\Sigma_{BA} &amp; \boldsymbol\Sigma_{BB}\end{bmatrix}\text{ with sizes }\begin{bmatrix} q \times q &amp; q \times (N-q) \\ (N-q) \times q &amp; (N-q) \times (N-q) \end{bmatrix}$$then the distribution of $x_A$ conditional on $x_B=b$ is multivariate normal $(x_A|x_B=b)\sim \mathcal{N}(\bar{\mu}, \bar{\Sigma})$ $$\bar{\boldsymbol\mu}=\boldsymbol\mu_A + \boldsymbol\Sigma_{AB} \boldsymbol\Sigma_{BB}^{-1}\left( \mathbf{B} - \boldsymbol\mu_B\right)$$and covariance matrix $$\overline{\boldsymbol\Sigma}=\boldsymbol\Sigma_{AA} - \boldsymbol\Sigma_{AB} \boldsymbol\Sigma_{BB}^{-1} \boldsymbol\Sigma_{BA}. $$Let us for our example take $X_5 = -2$. We have: $x_A = [x_1, x_2, x_3, x_4]$ and $x_B = [x_5]$ Assuming the covariance matrix of size 5 X 5 is referred as $C$ $$\boldsymbol\Sigma_{AA}=\begin{bmatrix} C_{11} &amp; C_{12} &amp; C_{13} &amp; C_{14}\\ C_{21} &amp; C_{22} &amp; C_{23} &amp; C_{24}\\ C_{31} &amp; C_{32} &amp; C_{33} &amp; C_{34}\\ C_{41} &amp; C_{42} &amp; C_{43} &amp; C_{44}\\\end{bmatrix} \\$$$$\boldsymbol\Sigma_{AB}=\begin{bmatrix} C_{15}\\ C_{25}\\ C_{35}\\ C_{45}\\\end{bmatrix}$$$$\boldsymbol\Sigma_{BA}=\begin{bmatrix} C_{51}&amp; C_{52} &amp; C_{53} &amp; C_{54}\\\end{bmatrix}$$$$\boldsymbol\Sigma_{BB}=\begin{bmatrix} C_{55}\\\end{bmatrix}$$Putting in the numbers we get:       sigma_AA = covariance_5d[:4, :4]          sigma_AA  array([[1. , 0. 9, 0. 8, 0. 6],    [0. 9, 1. , 0. 9, 0. 8],    [0. 8, 0. 9, 1. , 0. 9],    [0. 6, 0. 8, 0. 9, 1. ]])        sigma_AB = covariance_5d[:4, 4]. reshape(-1, 1)          sigma_AB  array([[0. 4],    [0. 6],    [0. 8],    [0. 9]])        sigma_BA = covariance_5d[4, :4]. reshape(1, -1)          sigma_BA  array([[0. 4, 0. 6, 0. 8, 0. 9]])        sigma_BB = covariance_5d[4, 4]. reshape(-1, 1)          sigma_BB  array([[1. ]])  Now, calculating $\bar{\mu}$       mu_bar = np. zeros((4, 1)) + sigma_AB@np. linalg. inv(sigma_BB)*(-2)          mu_bar  array([[-0. 8],    [-1. 2],    [-1. 6],    [-1. 8]])  Since, $x_5$ has highest correlation with $x_4$ it makes sense for $x_5=-2$ to have the mean of $x_4$ to be close to -2. Now, calculating $\bar{\Sigma}$       sigma_bar = sigma_AA - sigma_AB@np. linalg. inv(sigma_BB)@sigma_BA          sigma_bar  array([[0. 84, 0. 66, 0. 48, 0. 24],    [0. 66, 0. 64, 0. 42, 0. 26],    [0. 48, 0. 42, 0. 36, 0. 18],    [0. 24, 0. 26, 0. 18, 0. 19]])  Now, we have the new mean and covariance matrices for $x_A = [x_1, x_2, x_3, x_4]$ and $x_B = [x_5] = [-2]$. Let us now draw some samples fixing $x_5 = -2$       cov = sigma_barmu = mu_bar. flatten()def plot_5d_samples_fixed_x2(random_num):  fig, ax = plt. subplots(ncols=2, figsize=(6, 3))      F = multivariate_normal(mu, cov)    sns. heatmap(cov, ax=ax[0], annot=True)  random_point = F. rvs(random_state=random_num)      data_array = pd. Series(random_point, index=[&#39;X1&#39;,&#39;X2&#39;,&#39;X3&#39;,&#39;X4&#39;])  data_array[&#39;X5&#39;] = -2  data_array. plot(ax=ax[1], kind=&#39;line&#39;, marker=&#39;. &#39;,color=&#39;k&#39;)  plt. scatter([4], [-2], color=&#39;red&#39;, s=100)  plt. xticks(np. arange(len(data_array. index)), data_array. index. values)  ax[1]. set_ylim(-3, 3)  for i in range(2):    format_axes(ax[i])    ax[0]. set_title(&quot;Covariance Matrix&quot;)  ax[-1]. set_title(&quot;Visualising the point&quot;)  plt. suptitle(f&quot;Random state = {random_num}&quot;, y=1. 1)  plt. tight_layout()  import os  if not os. path. exists(&quot;images/5d/conditional/1&quot;):    os. makedirs(&quot;images/5d/conditional/1&quot;)    plt. savefig(f&quot;images/5d/conditional/1/{random_num}. jpg&quot;, bbox_inches=&quot;tight&quot;)  plt. close()            for i in range(20):  plot_5d_samples_fixed_x2(i)          !convert -delay 20 -loop 0 images/5d/conditional/1/*. jpg 5d-conditional-1. gif     Let's increase to 20 dimensions now!&#182;: We can not surely write the covariance matrix for 20 dimensions. Let us use a small trick called the kernel function to create this matrix. We will come it later. For now, let us think of this function as a function which: outputs low numbers for $x_1$ and $x_2$ if they differ by a lotoutputs high number for $x_1$ and $x_2$ if they are very close      def rbf_kernel(x_1, x_2, sig):  return np. exp((-(x_1-x_2)**2)/2*(sig**2))          rbf_kernel(1, 1, 0. 4)  1. 0  Since 1=1, the above function evaluates to 1 showing that 1 is similar to 1       rbf_kernel(1, 2, 0. 4)  0. 9231163463866358  Since 1 and 2 are close, the function above evaluates to close to 1       rbf_kernel(1, 2, 1)  0. 6065306597126334  Ok, we use the same first two arguments 1 and 2 but change the last one to 1 from 0. 4 and we see that the function evaluates to a much smaller number. Thus, we can see that increase the sig parameter leads to quicker dropoff in similarity between pair of points. Or, in other words, higher sig means that the influence of a point x_1 reduces quicker. Let us now create the covariance matrix of size (20, 20) using this kernel function.       C = np. zeros((20, 20))          for i in range(20):  for j in range(20):    C[i, j] = rbf_kernel(i, j, 0. 5)    Let us plot the heatmap of the covariance matrix       sns. heatmap(C)  &lt;matplotlib. axes. _subplots. AxesSubplot at 0x7fb2d3922fd0&gt;  The above heatmap confirms that there is correlation between nearby points, but close to zero or zero correlation otherwise. Let us draw some samples from this 20 dimensional Gaussian&#182;:       def plot_20d_samples(random_num):  fig, ax = plt. subplots(figsize=(10, 3))      F = multivariate_normal(np. zeros(20), C)  random_point = F. rvs(random_state=random_num)  index = [f&#39;X{i}&#39; for i in range(1, 21)]  data_array = pd. Series(random_point, index=index)  data_array. plot(ax=ax, kind=&#39;line&#39;, marker=&#39;. &#39;,color=&#39;k&#39;)  plt. xticks(np. arange(len(data_array. index)), data_array. index. values)    plt. suptitle(f&quot;Random state = {random_num}&quot;, y=1. 1)  plt. tight_layout()  import os  if not os. path. exists(&quot;images/20d/&quot;):    os. makedirs(&quot;images/20d/&quot;)    plt. ylim(-3, 3)  plt. savefig(f&quot;images/20d/{random_num}. jpg&quot;, bbox_inches=&quot;tight&quot;)  plt. close()          for i in range(50):  plot_20d_samples(i)          !convert -delay 20 -loop 0 images/20d/*. jpg 20d. gif     From the animation above, we can see different family of functions of mean zero across these 20 points. We're really getting close now! Let us now condition on a few elements&#182;: We will create a new ordering of these variables such that the known variables occur towards the end. This allows for easy calculations for conditioning.       order = [2, 3, 4, 6, 7, 8, 9, 11, 12, 13, 14, 15, 16, 17, 18, 19, 0, 1, 5, 10]          new_C = np. zeros_like(C)          old_order = range(20)          for i in range(20):  for j in range(20):    new_C[i, j] = C[order[i], order[j]]          sns. heatmap(new_C, xticklabels=order, yticklabels=order, cmap=&#39;jet&#39;)  &lt;matplotlib. axes. _subplots. AxesSubplot at 0x7fb2d48a86d8&gt;  Now, we can condition on (x1 = 1, x2 = 3, x6 = -3, X11 = 1). We will use the same procedure we used above in the case of 5d.       B = np. array([1, 3, -3, 1]). reshape(-1, 1)B  array([[ 1],    [ 3],    [-3],    [ 1]])        sigma_AA_20d = new_C[:-B. size, :-B. size]sigma_AA_20d. shape  (16, 16)        sigma_BB_20d = new_C[-B. size:, -B. size:]sigma_BB_20d. shape  (4, 4)        sigma_AB_20d = new_C[:-B. size, -B. size:]sigma_AB_20d. shape  (16, 4)        sigma_BA_20d = new_C[-B. size:, :-B. size]sigma_BA_20d. shape  (4, 16)        mu_bar_20d = np. zeros((20-B. size, 1)) + sigma_AB_20d@np. linalg. inv(sigma_BB_20d)@(B)          sigma_bar_20d = sigma_AA_20d - sigma_AB_20d@np. linalg. inv(sigma_BB_20d)@sigma_BA_20d          sns. heatmap(sigma_bar_20d, xticklabels=order[:-B. size], yticklabels=order[:-B. size], cmap=&#39;jet&#39;)  &lt;matplotlib. axes. _subplots. AxesSubplot at 0x7fb2d9a90e48&gt;        def plot_20d_samples_known_x(random_num):  fig, ax = plt. subplots(figsize=(10, 3))      F = multivariate_normal(mu_bar_20d. flatten(), sigma_bar_20d)  random_point = F. rvs(random_state=random_num)  index = [f&#39;X{i+1}&#39; for i in order[:-B. size]]  data_array = pd. Series(random_point, index=index)  data_array[&#39;X1&#39;] = 1  data_array[&#39;X2&#39;] = 3  data_array[&#39;X6&#39;] = -3  data_array[&#39;X11&#39;] = -1    data_array = data_array[[f&#39;X{i+1}&#39; for i in range(20)]]  data_array. plot(ax=ax, kind=&#39;line&#39;, marker=&#39;. &#39;,color=&#39;k&#39;)  plt. xticks(np. arange(len(data_array. index)), data_array. index. values)  plt. scatter([0, 1,5, 10], [1, 3, -3, -1], color=&#39;red&#39;,s=100)  plt. suptitle(f&quot;Random state = {random_num}&quot;, y=1. 1)  plt. tight_layout()  import os  if not os. path. exists(&quot;images/20d/conditional/&quot;):    os. makedirs(&quot;images/20d/conditional/&quot;)  plt. grid()  plt. ylim(-4, 4)  plt. savefig(f&quot;images/20d/conditional/{random_num}. jpg&quot;, bbox_inches=&quot;tight&quot;)  plt. close()          for i in range(50):  plot_20d_samples_known_x(i)          !convert -delay 20 -loop 0 images/20d/conditional/*. jpg 20d-conditional. gif     From the plot above, we can see the known points in red and the other points wiggle to show the families of functions that we fit. Let us now draw a lot of samples and plot the mean and variance in these samples for the unknown X variables. We could have obtained the mean and variance directly using Gaussian marginalisation, but, for now let us just draw many samples.       F = multivariate_normal(mu_bar_20d. flatten(), sigma_bar_20d)dfs = {}for random_num in range(100):  random_point = F. rvs(random_state=random_num)  index = [f&#39;X{i+1}&#39; for i in order[:-B. size]]  data_array = pd. Series(random_point, index=index)  data_array[&#39;X1&#39;] = 1  data_array[&#39;X2&#39;] = 3  data_array[&#39;X6&#39;] = -3  data_array[&#39;X11&#39;] = -1    data_array = data_array[[f&#39;X{i+1}&#39; for i in range(20)]]  dfs[random_num] = data_array          fig, ax = plt. subplots(figsize=(10, 3))pd. DataFrame(dfs). mean(axis=1). plot(yerr=pd. DataFrame(dfs). std(axis=1),marker=&#39;o&#39;, color=&#39;k&#39;)plt. xticks(np. arange(len(data_array. index)), data_array. index. values)plt. scatter([0, 1,5, 10], [1, 3, -3, -1], color=&#39;red&#39;,s=100)format_axes(plt. gca())  &lt;matplotlib. axes. _subplots. AxesSubplot at 0x7fb2d37b2358&gt;  From the plot above, we can see the uncertainty (standard deviation) and the mean values for different variables. As expected, the uncertainty close to the known points (red) is low. Also, owing to the smooth nature of the covariance function we can see the means of unknown points close to known points are fairly similar. To summarise: We can very clearly see that there is low variance in zones where we have the known values and high variance otherwise. The farther we go away from a known value, the more is the variance! Kernels!&#182;: We will now take a small plunge into the world of kernels. As mentioned earlier, we will limit the discussion to generating to covariance matrix. We will be redefining the function mentioned above to include two parameters l and s s is the scale of variancel is the influence of the point to neighbouring points      def sig(x1, x2, l, s):  return s**2*(np. exp((-1/2*(l**2))*((x1-x2)**2)))          Cov_matrix = np. zeros((100, 100))          fig, ax = plt. subplots(ncols=4, sharex=True, sharey=True)s = 1for ix, l in enumerate([0. 001, 0. 01, 0. 1, 1]):  for i in range(100):    for j in range(100):      Cov_matrix[i, j] = sig(i, j, l, 1)  im = ax[ix]. imshow(Cov_matrix, cmap=&#39;jet&#39;)  ax[ix]. set_title(f&quot;l={l}&quot;)fig. subplots_adjust(right=0. 8)cbar_ax = fig. add_axes([0. 85, 0. 35, 0. 05, 0. 3])fig. colorbar(im, cax=cbar_ax)plt. suptitle(f&quot;Covariance matrix for varying l and s = {s}&quot;)  Text(0. 5, 0. 98, &#39;Covariance matrix for varying l and s = 1&#39;)  In the plot above, we can the covariance matrices for fixed s=1 and varying l. It can be seen that for very low l, the correlations between far away points is also significant. At l=1, this ceases to be the case.       fig, ax = plt. subplots(ncols=4, sharex=True, sharey=True, figsize=(12, 3))for ix, s in enumerate([1, 10, 20, 30]):  for i in range(100):    for j in range(100):      Cov_matrix[i, j] = sig(i, j, 0. 1, s)  sns. heatmap(Cov_matrix, cmap=&#39;jet&#39;, ax=ax[ix])  ax[ix]. set_title(f&quot;s={s}&quot;)plt. suptitle(&quot;Covariance matrix for varying s and l = 0. 1&quot;)  Text(0. 5, 0. 98, &#39;Covariance matrix for varying s and l = 0. 1&#39;)  Ok, this is great. We can see the different scales on the colorbars with increasing s and fixing l Now, let us try and redo the 20 point dataset with varying kernel parameters with conditioning on some known data.       def fit_plot_gp(kernel_s, kernel_l, known_data, total_data_points, save=False):  &quot;&quot;&quot;  kernel_s: sigma^2 param of kernel  kernel_l: l (width) param of kernel  known_data: {pos: value}  total_data_points  &quot;&quot;&quot;  o = list(range(20))  for key in known_data. keys():    o. remove(key)  o. extend(list(known_data. keys()))    C = np. zeros((total_data_points, total_data_points))  for i in range(total_data_points):    for j in range(total_data_points):      C[i, j] = sig(i, j, kernel_l, kernel_s)        # Making known variables shift  new_C = np. zeros_like(C)  for i in range(20):    for j in range(20):      new_C[i, j] = C[o[i], o[j]]  B = np. array(list(known_data. values())). reshape(-1, 1)    sigma_BA_20d = new_C[-B. size:, :-B. size]  sigma_AB_20d = new_C[:-B. size, -B. size:]  sigma_BB_20d = new_C[-B. size:, -B. size:]  sigma_AA_20d = new_C[:-B. size, :-B. size]  mu_bar_20d = np. zeros((20-B. size, 1)) + sigma_AB_20d@np. linalg. inv(sigma_BB_20d)@(B)  sigma_bar_20d = sigma_AA_20d - sigma_AB_20d@np. linalg. inv(sigma_BB_20d)@sigma_BA_20d  F = multivariate_normal(mu_bar_20d. flatten(), sigma_bar_20d)  dfs = {}  for random_num in range(100):    random_point = F. rvs(random_state=random_num)    index = [f&#39;X{i+1}&#39; for i in o[:-B. size]]    data_array = pd. Series(random_point, index=index)    for k, v in known_data. items():      data_array[f&#39;X{k+1}&#39;] = v        data_array = data_array[[f&#39;X{i+1}&#39; for i in range(20)]]    dfs[random_num] = data_array  fig, ax = plt. subplots(figsize=(10, 3))  mean_vector = pd. DataFrame(dfs). mean(axis=1)  mean_vector. plot(marker=&#39;. &#39;, color=&#39;k&#39;)  yerr=pd. DataFrame(dfs). std(axis=1)    plt. fill_between(range(len(mean_vector)), mean_vector+yerr, mean_vector-yerr, color=&#39;gray&#39;,alpha=0. 4)  plt. xticks(np. arange(len(data_array. index)), data_array. index. values)  plt. scatter(list(known_data. keys()), list(known_data. values()), color=&#39;gray&#39;,s=200,zorder=1)  format_axes(plt. gca())  plt. title(f&quot; l = {kernel_l} and s = {kernel_s}&quot;)  import os  if save:    if not os. path. exists(&quot;images/20d/conditional-points/&quot;):      os. makedirs(&quot;images/20d/conditional-points/&quot;)    plt. grid()    plt. xticks(np. arange(len(data_array. index)), np. arange(len(data_array. index)))    plt. ylim(-4, 4)    plt. title(f&quot;Known data: {known_data}&quot;)    plt. savefig(f&quot;images/20d/conditional-points/{len(known_data. keys())}. jpg&quot;, bbox_inches=&quot;tight&quot;)    plt. close()              known_d = {0:-2, 1:3, 9:-1, 14:-1}          fit_plot_gp(1, 0. 5, known_d, 20)    The above plot shows the uncertainty and the family of functions for l=0. 5 and s=1.       fit_plot_gp(5, 0. 5, known_d, 20)    Keeping l=0. 5, the above plot shows how increasing s increases the uncertainty of estimation.       fit_plot_gp(1, 1, known_d, 20)    The above plot shows how increasing l reduces the influence between far away points.       fit_plot_gp(1, 100, known_d, 20)    The above plot increases l to a very large value. Seems to be just moving around the mean?       np. random. seed(0)order_points_added = np. random. choice(range(20), size=9, replace=False)k = {}for i in range(9):  k[order_points_added[i]] = np. random. choice(range(-3, 3))  fit_plot_gp(1, 0. 5, k, 20, True)          !convert -delay 40 -loop 0 images/20d/conditional-points/*. jpg 20d-conditional-main. gif    Let us create a small animation where we keep on adding points and see how the uncertainty and estimation changes Creating a scikit-learn like function containing fit and predict&#182;: I'll now bring in the formal definitions, summarise the discussion and write a function akin to scikit-learn which can accept train data to estimate for test data. Formally defining GPs&#182;: A Gaussian process is fully specified by a mean function m(x) andcovariance function K(x, x'): $$f(x) \sim GP (m(x),K(x, x')$$Let us consider a case of noiseless GPs now Noiseless GPs&#182;: Given train data $$D = {(x_i, y_i), i = 1:N}$$ Given a test set $X_{*}$ of size $N_* \times d $ containing $N_*$ points in ${\rm I\!R}^d$, we want to predict function outputs $y_{*}$ We can write: $$\begin{pmatrix} y \\ y_*\end{pmatrix} \sim \mathcal{N} \left( \begin{pmatrix} \mu \\ \mu_*\end{pmatrix} , \begin{pmatrix} K &amp; K_* \\ K_*^T &amp; K_{**}\end{pmatrix} \right)$$where $$K = Ker(X, X) \in {\rm I\!R}^{N\times N}\\K_* = Ker(X, X_*) \in {\rm I\!R}^{N\times N_*}\\K_{**} = Ker(X_*, X_*) \in {\rm I\!R}^{N_*\times N_*}\\$$We had previously used the kernel which we will continue to use def sig(x1, x2, l, s):  return s**2*(np. exp((-1/2*(l**2))*((x1-x2)**2)))We can then write: $$p(y_*|X_*, X, y) \sim \mathcal{N}(\mu', \Sigma') \\\mu' = \mu_* + K_*^TK^{-1}(x-\mu) \\\Sigma' = K_{**} - K_*^TK^{-1}K_*$$      class NoiselessGP_inversion:  def __init__(self, l=0. 1, s=1, prior_mean=0):    self. l = l    self. s = s       self. prior_mean = prior_mean      def prior_sample(self, x, n):    &quot;&quot;&quot;    Sample GP on x    &quot;&quot;&quot;    self. sample_k = self. create_cov_matrix(x, x, self. l, self. s)    for i in range(n):      pass       def kernel(self, a, b, l, s):    &quot;&quot;&quot;    Borrowed from Nando De Freita&#39;s lecture code    https://www. cs. ubc. ca/~nando/540-2013/lectures/gp. py    &quot;&quot;&quot;    sqdist = np. sum(a**2,1). reshape(-1,1) + np. sum(b**2,1) - 2*np. dot(a, b. T)    return s**2*np. exp(-. 5 * (1/l) * sqdist)    def fit(self, train_x, train_y):    self. train_x = train_x    self. train_y = train_y    self. N = len(train_x)    self. K = self. kernel(train_x, train_x, self. l, self. s)              def predict(self, test_x):    self. N_star = len(test_x)    self. K_star = self. kernel(self. train_x, test_x, self. l, self. s)    self. K_star_star = self. kernel(test_x, test_x, self. l, self. s)    self. posterior_mu = self. prior_mean + self. K_star. T@np. linalg. inv(self. K)@(self. train_y-self. prior_mean)    self. posterior_sigma = self. K_star_star - self. K_star. T@np. linalg. inv(self. K)@self. K_star    return self. posterior_mu, self. posterior_sigma          clf = NoiselessGP_inversion()          train_x = np. array([-4, -3, -2, -1, 1]). reshape(5,1)train_y = np. sin(train_x)test_x = np. linspace(-5, 5, 50). reshape(-1, 1)test_y = np. sin(test_x)          plt. plot(train_x, train_y,&#39;ko-&#39;)  [&lt;matplotlib. lines. Line2D at 0x7fb2d954f198&gt;]        clf. fit(train_x, train_y)          posterior_mu, posterior_var = clf. predict(test_x)          plt. plot(test_x, clf. posterior_mu,&#39;k&#39;,label=&#39;Predicted&#39;,lw=1)plt. plot(test_x, test_y, &#39;purple&#39;,label=&#39;GT&#39;,lw=2)plt. plot(train_x, train_y, &#39;ko&#39;,label=&#39;Training Data&#39;)plt. fill_between(test_x. flatten(),         (clf. posterior_mu. flatten() - clf. posterior_sigma. diagonal(). flatten()),         (clf. posterior_mu. flatten() + clf. posterior_sigma. diagonal(). flatten()),         color=&#39;gray&#39;, alpha=0. 3        )plt. legend()format_axes(plt. gca())  &lt;matplotlib. axes. _subplots. AxesSubplot at 0x7fb2d9516518&gt;  Cholesky decomposition&#182;: We had previously used matrix inversion to do the computation for computing the posterior mean and variance in our GP. However, the matrices involved may be poorly conditioned and thus Cholesky decomposition is often favoured. From Wikipedia, the Cholesky decomposition of a matrix $A$ is given as:$$\mathbf{A} = \mathbf{L L}^T$$ where $L$ is a real lower triangular matrix. We can thus re-write the posterior mean and covariance as: $$p(y_*|X_*, X, y) \sim \mathcal{N}(\mu', \Sigma') \\K = LL^T \\$$We are now going to use the \ as follows:if $A\omega = B$, then $\omega$ = $B$ \ $A$ We now have:$$\alpha = K^{-1}(x-\mu) \\or, \alpha = {LL^T}^{-1}(x-\mu) \\or, \alpha = L^{-T}L^{-1}(x-\mu) \\Let, K^{-1}(x-\mu) = \beta \\Thus, L^{-T}L^{-1}(x-\mu) = \beta \\Let, L^{-1}(x-\mu) = \gamma\\Thus, L\gamma = x-\mu \\Thus, \gamma = L \setminus (x-\mu)\\\Thus, \alpha = L^{T} \setminus (L \setminus (x-\mu))$$ In Python, the same can be written as: L = np. linalg. cholesky(K)  alpha = np. linalg. solve(L. T, np. linalg. solve(L, x-mu))Thus, we can find the posterior mean as:$$\mu' = \mu_* + K_*^T \alpha \\$$ We also know that$$\Sigma' = K_{**} - K_*^TK^{-1}K_*$$ Let us now define$$v = L \setminus K_{*}\\or, v = L^{-1}K_{*}\\Thus, v^{T} = K_{*}^TL^{-T}\\Thus, v^{T}v = K_{*}^TL^{-T}L^{-1}K_{*}\\Thus, v^{T}v = K_*^TK^{-1}K_* = K_{**} - \Sigma' $$ Let us know rewrite the code with Cholesky decomposition.       class NoiselessGP_Cholesky:  def __init__(self, l=0. 1, s=1, prior_mean=0):    self. l = l    self. s = s       self. prior_mean = prior_mean      def prior_sample(self, x, n):    &quot;&quot;&quot;    Sample GP on x    &quot;&quot;&quot;    self. sample_k = self. create_cov_matrix(x, x, self. l, self. s)    for i in range(n):      pass       def kernel(self, a, b, l, s):    &quot;&quot;&quot;    Borrowed from Nando De Freita&#39;s lecture code    https://www. cs. ubc. ca/~nando/540-2013/lectures/gp. py    &quot;&quot;&quot;    sqdist = np. sum(a**2,1). reshape(-1,1) + np. sum(b**2,1) - 2*np. dot(a, b. T)    return s**2*np. exp(-. 5 * (1/l) * sqdist)    def fit(self, train_x, train_y):    self. train_x = train_x    self. train_y = train_y    self. N = len(train_x)    self. K = self. kernel(train_x, train_x, self. l, self. s)    self. L = np. linalg. cholesky(self. K)              def predict(self, test_x):    self. N_star = len(test_x)    self. K_star = self. kernel(self. train_x, test_x, self. l, self. s)    self. K_star_star = self. kernel(test_x, test_x, self. l, self. s)    self. alpha = np. linalg. solve(self. L. T, np. linalg. solve(self. L, self. train_y-self. prior_mean))    self. v = np. linalg. solve(self. L, self. K_star)    self. posterior_mu = self. prior_mean + self. K_star. T@self. alpha    self. posterior_sigma = self. K_star_star - self. v. T@self. v    return self. posterior_mu, self. posterior_sigma          clf = NoiselessGP_Cholesky()clf. fit(train_x, train_y)posterior_mu_cholesky, posterior_var_cholesky = clf. predict(test_x)    We will now compare our Cholesky decomposition based decompostion with the earlier one.       np. allclose(posterior_mu_cholesky, posterior_mu)  True        np. allclose(posterior_var_cholesky, posterior_var)  True  Ok, all looks good till now! Let us now move on to the case for Noisy GPs. Noisy GPs&#182;: Previously, we had assumed a noiseless model, which is to say, for the observed data, we had:$$y_i = f(x_i)$$ We now make the model more flexible by saying that there can be noise in the observed data as well, thus:$$y_i = f(x_i) + \epsilon \\\epsilon \sim \mathcal{N}(0, \sigma_y^2)$$ One of the main difference compared to the noiseless model would be that in the noisy model, we will have some uncertainty even about the training points. Everything about our model remains the same, except for the change in the covariance matrix $K$ for the training points, which is now given as: $$K_y = \sigma_y^2\mathbf{I_n} + K$$We can now rewrite the function as follows:       class NoisyGP:  def __init__(self, l = 0. 1, s = 1, prior_mean = 0, sigma_y = 1):    self. l = l    self. s = s       self. prior_mean = prior_mean    self. sigma_y = sigma_y      def prior_sample(self, x, n):    &quot;&quot;&quot;    Sample GP on x    &quot;&quot;&quot;    self. sample_k = self. create_cov_matrix(x, x, self. l, self. s)    for i in range(n):      pass       def kernel(self, a, b, l, s):    &quot;&quot;&quot;    Borrowed from Nando De Freita&#39;s lecture code    https://www. cs. ubc. ca/~nando/540-2013/lectures/gp. py    &quot;&quot;&quot;    sqdist = np. sum(a**2,1). reshape(-1,1) + np. sum(b**2,1) - 2*np. dot(a, b. T)    return s**2*np. exp(-. 5 * (1/l) * sqdist)    def fit(self, train_x, train_y):    self. train_x = train_x    self. train_y = train_y    self. N = len(train_x)    self. K = self. kernel(train_x, train_x, self. l, self. s) + self. sigma_y*np. eye(len(train_x))    self. L = np. linalg. cholesky(self. K)              def predict(self, test_x):    self. N_star = len(test_x)    self. K_star = self. kernel(self. train_x, test_x, self. l, self. s)    self. K_star_star = self. kernel(test_x, test_x, self. l, self. s)    self. alpha = np. linalg. solve(self. L. T, np. linalg. solve(self. L, self. train_y-self. prior_mean))    self. v = np. linalg. solve(self. L, self. K_star)    self. posterior_mu = self. prior_mean + self. K_star. T@self. alpha    self. posterior_sigma = self. K_star_star - self. v. T@self. v    return self. posterior_mu, self. posterior_sigma          clf = NoisyGP(sigma_y=0. 2)clf. fit(train_x, train_y)posterior_mu_noisy, posterior_var_noisy = clf. predict(test_x)          plt. plot(test_x, clf. posterior_mu,&#39;k&#39;,label=&#39;Predicted&#39;,lw=1)plt. plot(test_x, test_y, &#39;purple&#39;,label=&#39;GT&#39;,lw=2)plt. plot(train_x, train_y, &#39;ko&#39;,label=&#39;Training Data&#39;)plt. fill_between(test_x. flatten(),         (clf. posterior_mu. flatten() - clf. posterior_sigma. diagonal(). flatten()),         (clf. posterior_mu. flatten() + clf. posterior_sigma. diagonal(). flatten()),         color=&#39;gray&#39;, alpha=0. 3        )plt. legend()format_axes(plt. gca())  &lt;matplotlib. axes. _subplots. AxesSubplot at 0x7fb2d4725978&gt;  We can now see that our model has some uncertainty even on the train points! "
    }, {
    "id": 6,
    "url": "https://nipunbatra.github.io/academia/2018/08/18/Placement-Preparation-2018-1-HashMap.html",
    "title": "Placement-Preparation-2018-1-HashMap",
    "body": "2018/08/18 -           In this blogpost, we will take a question from Cracking the Coding Interview. I discussed this question with Masters students at IITGN. We came up with some great answers. I'll show how we increasingly went towards better solutions starting from naive ones. Problem statement Find all integer solutions to the problem$a^3 + b^3 = c^3 + d^3$ where $1&lt;=a&lt;=n,1&lt;=b&lt;=n,1&lt;=c&lt;=n,1&lt;=d&lt;=n$ First attempt : Naive bruteforce $O(n^4)$&#182;: Let's write a very simple first attempt. We will write four nested loops. This will be $O(n^4)$ solution.       def f1(n):  out = []  for a in range(1, n+1):    for b in range(1, n+1):      for c in range(1, n+1):        for d in range(1, n+1):          if a**3 + b**3 == c**3 + d**3:            out. append((a, b, c, d))  return out           f1_time = %timeit -o f1(50)  6. 65 s ± 203 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)        f1_time. average  6. 646897936570895  Second attempt : Reduce computations in brute force method&#182;: Let's now try to optimise f1. We will still use a solution of $O(n^4)$ solution. However, we add one small optimisation fo f1. We break from the innermost loop once we find a match. This will hopefull save us some computations.       def f2(n):  out = []  for a in range(1, n+1):    for b in range(1, n+1):      for c in range(1, n+1):        for d in range(1, n+1):          if a**3 + b**3 == c**3 + d**3:            out. append((a, b, c, d))            break  return out           f2_time = %timeit -o f2(50)  6. 29 s ± 26. 3 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)  Ok. We're little better than f1. Every reduced computation is time saved! Third attempt : Reduce repeated computations by saving cubes of numbers&#182;: One of the student came up with an excellent observation. Why should we keep on computing cubes of numbers? This is a repeated operation. Let's instead store them in a dictionary.       def f3(n):  cubes = {}  for x in range(1, n+1):    cubes[x] = x**3  out = []  for a in range(1, n+1):    for b in range(1, n+1):      for c in range(1, n+1):        for d in range(1, n+1):          if cubes[a] + cubes[b] == cubes[c] + cubes[d]:            out. append((a, b, c, d))            break  return out           f3_time = %timeit -o f3(50)  1. 05 s ± 4. 11 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)  Ok. We now mean business! This is about 6 times quicker than our previous version. Fourth attempt : Reduce one loop $O(n^3)$&#182;: In this solution, we will reduce one loop. We can solve for $d^3 = a^3 + b^3 - c^3$ and find all the integer solutions. Now, there's another clever optimisation that I have added. We can precompute the cubes and the cuberoots corresponding to numbers from 1 to N and perfect cubes from 1 to $N^3$ respectively.       def f4(n):  cubes = {}  cuberoots = {}  for x in range(1, n+1):    x3 = x**3    cubes[x] = x3    cuberoots[x3] = x  out = []  for a in range(1, n+1):    for b in range(1, n+1):      for c in range(1, n+1):        d3 = (cubes[a] + cubes[b] - cubes[c])        if d3 in cuberoots:          out. append((a, b, c, cuberoots[d3]))  return out           f4_time = %timeit -o f4(50)  21. 7 ms ± 1. 99 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)  This is seriously fast now! Fifth attempt : Reduce another loop $O(n^2)$&#182;: In this solution, we will reduce one more loop. We can compute $a^3 + b^3$ for all a, b. And then find c and d where $c^3 + d^3$ is the same as $a^3 + b^3$. This has a few Python tricks inside! One of the special cases to handle is of the type $1^3 + 2^3 = 2^3 + 1^3$       def f5(n):  out = []  cubes = {}  for x in range(1, n+1):    cubes[x] = x**3    sum_a3_b3 = {}  for a in range(1, n+1):    for b in range(1, n+1):      temp = cubes[a]+cubes[b]      if temp in sum_a3_b3:          sum_a3_b3[temp]. append((a, b))      else:        sum_a3_b3[temp] = [(a, b)]  for c in range(1, n+1):    for d in range(1, n+1):      sum_c3_d3 = cubes[c] + cubes[d]      if sum_c3_d3 in sum_a3_b3:        for (a, b) in sum_a3_b3[sum_c3_d3]:          out. append((a, b, c, d))  return out          f5_time = %timeit -o f5(50)  1. 97 ms ± 235 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)  Plain Wow! Going from 6 seconds to about 2 ms! Let's plot the timings on a log scale to learn more.       %matplotlib inlineimport matplotlib. pyplot as pltimport pandas as pd          s = pd. Series({&#39;Naive (O(N^4))&#39;:f1_time. average,       &#39;Naive (O(N^4)) with break&#39;:f2_time. average,       &#39;Naive (O(N^4)) with break and precomputing cubes&#39;:f3_time. average,       &#39;(O(N^3))&#39;:f4_time. average,       &#39;(O(N^2))&#39;:f5_time. average})          s. plot(kind=&#39;bar&#39;, logy=True)plt. ylabel(&quot;Time&quot;);    Hope this was fun! "
    }, {
    "id": 7,
    "url": "https://nipunbatra.github.io/academia/2018/08/11/academics-time.html",
    "title": "An illustrative view of how academics spend their time!",
    "body": "2018/08/11 -  "
    }, {
    "id": 8,
    "url": "https://nipunbatra.github.io/sustainability/2018/06/26/map-electricity-access.html",
    "title": "Visualising Electricity Access Over Space and Time",
    "body": "2018/06/26 -           In this post, I'll explore electricity access, i. e. globally what fraction of people have access to electricity. Beyond the goal of finding the electricity access, this post will also serve to illustrate how the coolness coefficient of the Python visualisation ecosystem! I'll be using data from World Bank for electricity access. See the image below for the corresponding page.  Downloading World Bank data&#182;: Now, a Python package called wbdata provides a fairly easy way to access World Bank data. I'd be using it to get data in Pandas DataFrame.       %matplotlib inlineimport pandas as pdimport wbdataimport matplotlib. pyplot as pltimport datetimedata_date = (datetime. datetime(1990, 1, 1), datetime. datetime(2016, 1, 1))df_elec = wbdata. get_data(&quot;EG. ELC. ACCS. ZS&quot;, pandas=True, data_date=data_date)          df_elec. head()  country   dateArab World 2016  88. 768654      2015  88. 517967      2014  88. 076774      2013  88. 389705      2012  87. 288244Name: value, dtype: float64  Downloading Geodata and Reading Using GeoPandas&#182;: I'd now be downloading shapefile data for different countries. This will help us to spatially plot the data for the different countries.       !wget http://naciscdn. org/naturalearth/10m/cultural/ne_10m_admin_0_countries_lakes. zip  --2018-06-26 15:52:50-- http://naciscdn. org/naturalearth/10m/cultural/ne_10m_admin_0_countries_lakes. zipResolving naciscdn. org (naciscdn. org). . . 146. 201. 97. 163Connecting to naciscdn. org (naciscdn. org)|146. 201. 97. 163|:80. . . connected. HTTP request sent, awaiting response. . . 200 OKLength: 5077755 (4. 8M) [application/x-zip-compressed]Saving to: ‘ne_10m_admin_0_countries_lakes. zip’ne_10m_admin_0_coun 100%[===================&gt;]  4. 84M  246KB/s  in 22s   2018-06-26 15:53:12 (228 KB/s) - ‘ne_10m_admin_0_countries_lakes. zip’ saved [5077755/5077755]  Extracting shapefile&#182;:       import zipfilezip_ref = zipfile. ZipFile(&#39;ne_10m_admin_0_countries_lakes. zip&#39;, &#39;r&#39;)zip_ref. extractall(&#39;. &#39;)zip_ref. close()          import geopandas as gpdgdf = gpd. read_file(&#39;ne_10m_admin_0_countries_lakes. shp&#39;)[[&#39;ADM0_A3&#39;, &#39;geometry&#39;]]          gdf. head()           ADM0_A3   geometry         0   IDN   (POLYGON ((117. 7036079039552 4. 163414542001791. . .        1   MYS   (POLYGON ((117. 7036079039552 4. 163414542001791. . .        2   CHL   (POLYGON ((-69. 51008875199994 -17. 506588197999. . .        3   BOL   POLYGON ((-69. 51008875199994 -17. 5065881979999. . .        4   PER   (POLYGON ((-69. 51008875199994 -17. 506588197999. . .      Visualising electricity access in 2016&#182;: Getting electricity access data for 2016&#182;:       df_2016 = df_elec. unstack()[[&#39;2016&#39;]]. dropna()          df_2016. head()        date   2016       country            Afghanistan   84. 137138       Albania   100. 000000       Algeria   99. 439568       Andorra   100. 000000       Angola   40. 520607     In order to visualise electricity access data over the map, we would have to join the GeoPandas object gdf and df_elec Joining gdf and df_2016&#182;: Now, gdf uses alpha_3 codes for country names like AFG, etc. , whereas df_2016 uses country names. We will thus use pycountry package to get code names corresponding to countries in df_2016 as shown in this StackOverflow post.       import pycountrycountries = {}for country in pycountry. countries:  countries[country. name] = country. alpha_3codes = [countries. get(country, &#39;Unknown code&#39;) for country in df_2016. index]df_2016[&#39;Code&#39;] = codes          df_2016. head()        date   2016   Code       country               Afghanistan   84. 137138   AFG       Albania   100. 000000   ALB       Algeria   99. 439568   DZA       Andorra   100. 000000   AND       Angola   40. 520607   AGO     Now, we can join the two data sources       merged_df_2016 = gpd. GeoDataFrame(pd. merge(gdf, df_2016, left_on=&#39;ADM0_A3&#39;, right_on=&#39;Code&#39;))          merged_df_2016. head()           ADM0_A3   geometry   2016   Code         0   IDN   (POLYGON ((117. 7036079039552 4. 163414542001791. . .    97. 620000   IDN       1   MYS   (POLYGON ((117. 7036079039552 4. 163414542001791. . .    100. 000000   MYS       2   CHL   (POLYGON ((-69. 51008875199994 -17. 506588197999. . .    100. 000000   CHL       3   PER   (POLYGON ((-69. 51008875199994 -17. 506588197999. . .    94. 851746   PER       4   ARG   (POLYGON ((-68. 4486097329999 -52. 3466170159999. . .    100. 000000   ARG     Finally plotting!&#182;:       # Example borrowed from http://ramiro. org/notebook/geopandas-choropleth/cmap=&#39;OrRd&#39;figsize = (16, 5)ax = merged_df_2016. plot(column=&#39;2016&#39;, cmap=cmap, figsize=figsize,legend=True)title = &#39;Electricity Access(% of population) in {}&#39;. format(&#39;2016&#39;)gdf[~gdf. ADM0_A3. isin(merged_df_2016. ADM0_A3)]. plot(ax=ax, color=&#39;#fffafa&#39;, hatch=&#39;///&#39;)ax. set_title(title, fontdict={&#39;fontsize&#39;: 15}, loc=&#39;left&#39;)ax. set_axis_off()    Creating animation for access across time&#182;:       !mkdir -p elec_access          def save_png_year(year, path=&quot;elec_access&quot;):  df_year = df_elec. unstack()[[&#39;{}&#39;. format(year)]]. dropna()  codes = [countries. get(country, &#39;Unknown code&#39;) for country in df_year. index]  df_year[&#39;Code&#39;] = codes  merged_df_year = gpd. GeoDataFrame(pd. merge(gdf, df_year, left_on=&#39;ADM0_A3&#39;, right_on=&#39;Code&#39;))  figsize = (16, 5)  ax = merged_df_year. plot(column=&#39;{}&#39;. format(year), cmap=cmap, figsize=figsize,legend=True,vmin=0. 0, vmax=100. 0)  title = &#39;Electricity Access(% of population) in {}&#39;. format(year)  gdf[~gdf. ADM0_A3. isin(merged_df_year. ADM0_A3)]. plot(ax=ax, color=&#39;#fffafa&#39;, hatch=&#39;///&#39;)  ax. set_title(title, fontdict={&#39;fontsize&#39;: 15}, loc=&#39;left&#39;)  ax. set_axis_off()  plt. savefig(&#39;{}/{}. png&#39;. format(path, year), dpi=300)  plt. close()          for year in range(1990, 2017):  save_png_year(year)          # Borrowed from http://www. kevinwampler. com/blog/2016/09/10/creating-animated-gifs-using-python. htmldef create_gifv(input_files, output_base_name, fps):  import imageio  output_extensions = [&quot;gif&quot;]  input_filenames = [&#39;elec_access/{}. png&#39;. format(year) for year in range(1990, 2017)]  poster_writer = imageio. get_writer(&quot;{}. png&quot;. format(output_base_name), mode=&#39;i&#39;)  video_writers = [    imageio. get_writer(&quot;{}. {}&quot;. format(output_base_name, ext), mode=&#39;I&#39;, fps=fps)    for ext in output_extensions]  is_first = True  for filename in input_filenames:    img = imageio. imread(filename)    for writer in video_writers:      writer. append_data(img)    if is_first:      poster_writer. append_data(img)    is_first = False  for writer in video_writers + [poster_writer]:    writer. close()          create_gifv(&quot;elec_access/*. png&quot;, &quot;electricity_access&quot;, 4)     Across Africa and SE Asia, one can clearly see a gradual improvement in access! Hope you had fun reading this post :) "
    }, {
    "id": 9,
    "url": "https://nipunbatra.github.io/air%20quality/2018/06/21/aq-india-map.html",
    "title": "Mapping location of air quality sensing in India",
    "body": "2018/06/21 -           In this notebook, I'll show a quick example of how to use Folium (which internally uses LeafletJS) for visualising the location of air quality monitors in India. The purpose of this notebook is eductional in nature. Standard Imports&#182;:       import numpy as npimport matplotlib. pyplot as pltimport pandas as pd%matplotlib inline    Downloading data from OpenAQ for 2018-04-06&#182;:       !wget --no-check-certificate https://openaq-data. s3. amazonaws. com/2018-04-06. csv -P /Users/nipun/Downloads/  --2020-02-29 17:52:50-- https://openaq-data. s3. amazonaws. com/2018-04-06. csvResolving openaq-data. s3. amazonaws. com (openaq-data. s3. amazonaws. com). . . 52. 216. 99. 123Connecting to openaq-data. s3. amazonaws. com (openaq-data. s3. amazonaws. com)|52. 216. 99. 123|:443. . . connected. WARNING: cannot verify openaq-data. s3. amazonaws. com&#39;s certificate, issued by ‘CN=DigiCert Baltimore CA-2 G2,OU=www. digicert. com,O=DigiCert Inc,C=US’: Unable to locally verify the issuer&#39;s authority. HTTP request sent, awaiting response. . . 200 OKLength: 133839107 (128M) [text/csv]Saving to: ‘/Users/nipun/Downloads/2018-04-06. csv. 1’2018-04-06. csv. 1   37%[======&gt;       ] 47. 37M 3. 79MB/s  eta 40s  ^C        import pandas as pddf = pd. read_csv(&quot;/Users/nipun/Downloads/2018-04-06. csv&quot;)df = df[(df. country==&#39;IN&#39;)&amp;(df. parameter==&#39;pm25&#39;)]. dropna(). groupby(&quot;location&quot;). mean()          df           value   latitude   longitude       location                  Adarsh Nagar, Jaipur - RSPCB   79. 916667   26. 902909   75. 836853       Anand Kala Kshetram, Rajamahendravaram - APPCB   42. 750000   16. 987287   81. 736318       Ardhali Bazar, Varanasi - UPPCB   103. 666667   25. 350599   82. 908307       Asanol Court Area, Asanol - WBPCB   56. 833333   23. 685297   86. 945968       Ashok Nagar, Udaipur - RSPCB   114. 750000   24. 588617   73. 632140       . . .    . . .    . . .    . . .        Vasundhara, Ghaziabad, UP - UPPCB   223. 333333   28. 660335   77. 357256       Vikas Sadan, Gurgaon, Haryana - HSPCB   280. 250000   28. 450124   77. 026305       Vindhyachal STPS, Singrauli - MPPCB   144. 000000   24. 108970   82. 645580       Ward-32 Bapupara, Siliguri - WBPCB   195. 000000   26. 688305   88. 412668       Zoo Park, Hyderabad - TSPCB   82. 500000   17. 349694   78. 451437   79 rows × 3 columns   Downloading World GeoJson file&#182;:       !wget --no-check-certificate https://raw. githubusercontent. com/python-visualization/folium/master/examples/data/world-countries. json  --2020-02-29 17:53:17-- https://raw. githubusercontent. com/python-visualization/folium/master/examples/data/world-countries. jsonResolving raw. githubusercontent. com (raw. githubusercontent. com). . . 151. 101. 8. 133Connecting to raw. githubusercontent. com (raw. githubusercontent. com)|151. 101. 8. 133|:443. . . connected. WARNING: cannot verify raw. githubusercontent. com&#39;s certificate, issued by ‘CN=DigiCert SHA2 High Assurance Server CA,OU=www. digicert. com,O=DigiCert Inc,C=US’: Unable to locally verify the issuer&#39;s authority. HTTP request sent, awaiting response. . . 200 OKLength: 252515 (247K) [text/plain]Saving to: ‘world-countries. json’world-countries. jso 100%[===================&gt;] 246. 60K  376KB/s  in 0. 7s  2020-02-29 17:53:19 (376 KB/s) - ‘world-countries. json’ saved [252515/252515]  Creating india. json correspdonding to Indian data&#182;:       import jsone = json. load(open(&#39;world-countries. json&#39;,&#39;r&#39;))json. dump(e[&#39;features&#39;][73], open(&#39;india. json&#39;,&#39;w&#39;))          import foliumfolium_map = folium. Map(width = &#39;60%&#39;,height=800,location=[20, 77],            zoom_start=5,            tiles=&quot;Stamen Terrain&quot;,min_lat=7, max_lat=35, min_lon=73, max_lon=90)for x in df. iterrows():  name = x[0]  lat, lon = x[1][&#39;latitude&#39;], x[1][&#39;longitude&#39;]  folium. CircleMarker([lat, lon], radius=5, color=&#39;#000000&#39;,fill_color=&#39;#D3D3D3&#39; , fill_opacity=1). add_to(folium_map)folium. GeoJson(&#39;india. json&#39;). add_to(folium_map)  &lt;iframe src= about:blank  style= position:absolute;width:100%;height:100%;left:0;top:0;border:none !important;  data-html=PCFET0NUWVBFIGh0bWw+CjxoZWFkPiAgICAKICAgIDxtZXRhIGh0dHAtZXF1aXY9ImNvbnRlbnQtdHlwZSIgY29udGVudD0idGV4dC9odG1sOyBjaGFyc2V0PVVURi04IiAvPgogICAgCiAgICAgICAgPHNjcmlwdD4KICAgICAgICAgICAgTF9OT19UT1VDSCA9IGZhbHNlOwogICAgICAgICAgICBMX0RJU0FCTEVfM0QgPSBmYWxzZTsKICAgICAgICA8L3NjcmlwdD4KICAgIAogICAgPHNjcmlwdCBzcmM9Imh0dHBzOi8vY2RuLmpzZGVsaXZyLm5ldC9ucG0vbGVhZmxldEAxLjUuMS9kaXN0L2xlYWZsZXQuanMiPjwvc2NyaXB0PgogICAgPHNjcmlwdCBzcmM9Imh0dHBzOi8vY29kZS5qcXVlcnkuY29tL2pxdWVyeS0xLjEyLjQubWluLmpzIj48L3NjcmlwdD4KICAgIDxzY3JpcHQgc3JjPSJodHRwczovL21heGNkbi5ib290c3RyYXBjZG4uY29tL2Jvb3RzdHJhcC8zLjIuMC9qcy9ib290c3RyYXAubWluLmpzIj48L3NjcmlwdD4KICAgIDxzY3JpcHQgc3JjPSJodHRwczovL2NkbmpzLmNsb3VkZmxhcmUuY29tL2FqYXgvbGlicy9MZWFmbGV0LmF3ZXNvbWUtbWFya2Vycy8yLjAuMi9sZWFmbGV0LmF3ZXNvbWUtbWFya2Vycy5qcyI+PC9zY3JpcHQ+CiAgICA8bGluayByZWw9InN0eWxlc2hlZXQiIGhyZWY9Imh0dHBzOi8vY2RuLmpzZGVsaXZyLm5ldC9ucG0vbGVhZmxldEAxLjUuMS9kaXN0L2xlYWZsZXQuY3NzIi8+CiAgICA8bGluayByZWw9InN0eWxlc2hlZXQiIGhyZWY9Imh0dHBzOi8vbWF4Y2RuLmJvb3RzdHJhcGNkbi5jb20vYm9vdHN0cmFwLzMuMi4wL2Nzcy9ib290c3RyYXAubWluLmNzcyIvPgogICAgPGxpbmsgcmVsPSJzdHlsZXNoZWV0IiBocmVmPSJodHRwczovL21heGNkbi5ib290c3RyYXBjZG4uY29tL2Jvb3RzdHJhcC8zLjIuMC9jc3MvYm9vdHN0cmFwLXRoZW1lLm1pbi5jc3MiLz4KICAgIDxsaW5rIHJlbD0ic3R5bGVzaGVldCIgaHJlZj0iaHR0cHM6Ly9tYXhjZG4uYm9vdHN0cmFwY2RuLmNvbS9mb250LWF3ZXNvbWUvNC42LjMvY3NzL2ZvbnQtYXdlc29tZS5taW4uY3NzIi8+CiAgICA8bGluayByZWw9InN0eWxlc2hlZXQiIGhyZWY9Imh0dHBzOi8vY2RuanMuY2xvdWRmbGFyZS5jb20vYWpheC9saWJzL0xlYWZsZXQuYXdlc29tZS1tYXJrZXJzLzIuMC4yL2xlYWZsZXQuYXdlc29tZS1tYXJrZXJzLmNzcyIvPgogICAgPGxpbmsgcmVsPSJzdHlsZXNoZWV0IiBocmVmPSJodHRwczovL3Jhd2Nkbi5naXRoYWNrLmNvbS9weXRob24tdmlzdWFsaXphdGlvbi9mb2xpdW0vbWFzdGVyL2ZvbGl1bS90ZW1wbGF0ZXMvbGVhZmxldC5hd2Vzb21lLnJvdGF0ZS5jc3MiLz4KICAgIDxzdHlsZT5odG1sLCBib2R5IHt3aWR0aDogMTAwJTtoZWlnaHQ6IDEwMCU7bWFyZ2luOiAwO3BhZGRpbmc6IDA7fTwvc3R5bGU+CiAgICA8c3R5bGU+I21hcCB7cG9zaXRpb246YWJzb2x1dGU7dG9wOjA7Ym90dG9tOjA7cmlnaHQ6MDtsZWZ0OjA7fTwvc3R5bGU+CiAgICAKICAgICAgICAgICAgPG1ldGEgbmFtZT0idmlld3BvcnQiIGNvbnRlbnQ9IndpZHRoPWRldmljZS13aWR0aCwKICAgICAgICAgICAgICAgIGluaXRpYWwtc2NhbGU9MS4wLCBtYXhpbXVtLXNjYWxlPTEuMCwgdXNlci1zY2FsYWJsZT1ubyIgLz4KICAgICAgICAgICAgPHN0eWxlPgogICAgICAgICAgICAgICAgI21hcF82MGMyYmZlMTczNjA0ODhlYmU5MDhlZWNmOWU0ODZmOCB7CiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlOwogICAgICAgICAgICAgICAgICAgIHdpZHRoOiA2MC4wJTsKICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IDgwMC4wcHg7CiAgICAgICAgICAgICAgICAgICAgbGVmdDogMC4wJTsKICAgICAgICAgICAgICAgICAgICB0b3A6IDAuMCU7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIDwvc3R5bGU+CiAgICAgICAgCjwvaGVhZD4KPGJvZHk+ICAgIAogICAgCiAgICAgICAgICAgIDxkaXYgY2xhc3M9ImZvbGl1bS1tYXAiIGlkPSJtYXBfNjBjMmJmZTE3MzYwNDg4ZWJlOTA4ZWVjZjllNDg2ZjgiID48L2Rpdj4KICAgICAgICAKPC9ib2R5Pgo8c2NyaXB0PiAgICAKICAgIAogICAgICAgICAgICB2YXIgbWFwXzYwYzJiZmUxNzM2MDQ4OGViZTkwOGVlY2Y5ZTQ4NmY4ID0gTC5tYXAoCiAgICAgICAgICAgICAgICAibWFwXzYwYzJiZmUxNzM2MDQ4OGViZTkwOGVlY2Y5ZTQ4NmY4IiwKICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICBjZW50ZXI6IFsyMC4wLCA3Ny4wXSwKICAgICAgICAgICAgICAgICAgICBjcnM6IEwuQ1JTLkVQU0czODU3LAogICAgICAgICAgICAgICAgICAgIHpvb206IDUsCiAgICAgICAgICAgICAgICAgICAgem9vbUNvbnRyb2w6IHRydWUsCiAgICAgICAgICAgICAgICAgICAgcHJlZmVyQ2FudmFzOiBmYWxzZSwKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgKTsKCiAgICAgICAgICAgIAoKICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgdGlsZV9sYXllcl8yNmZlOTAxNmUwNDA0NDQ3YWU1N2M1YTRhMjJlNjMzZSA9IEwudGlsZUxheWVyKAogICAgICAgICAgICAgICAgImh0dHBzOi8vc3RhbWVuLXRpbGVzLXtzfS5hLnNzbC5mYXN0bHkubmV0L3RlcnJhaW4ve3p9L3t4fS97eX0uanBnIiwKICAgICAgICAgICAgICAgIHsiYXR0cmlidXRpb24iOiAiTWFwIHRpbGVzIGJ5IFx1MDAzY2EgaHJlZj1cImh0dHA6Ly9zdGFtZW4uY29tXCJcdTAwM2VTdGFtZW4gRGVzaWduXHUwMDNjL2FcdTAwM2UsIHVuZGVyIFx1MDAzY2EgaHJlZj1cImh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LzMuMFwiXHUwMDNlQ0MgQlkgMy4wXHUwMDNjL2FcdTAwM2UuIERhdGEgYnkgXHUwMDI2Y29weTsgXHUwMDNjYSBocmVmPVwiaHR0cDovL29wZW5zdHJlZXRtYXAub3JnXCJcdTAwM2VPcGVuU3RyZWV0TWFwXHUwMDNjL2FcdTAwM2UsIHVuZGVyIFx1MDAzY2EgaHJlZj1cImh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LXNhLzMuMFwiXHUwMDNlQ0MgQlkgU0FcdTAwM2MvYVx1MDAzZS4iLCAiZGV0ZWN0UmV0aW5hIjogZmFsc2UsICJtYXhOYXRpdmVab29tIjogMTgsICJtYXhab29tIjogMTgsICJtaW5ab29tIjogMCwgIm5vV3JhcCI6IGZhbHNlLCAib3BhY2l0eSI6IDEsICJzdWJkb21haW5zIjogImFiYyIsICJ0bXMiOiBmYWxzZX0KICAgICAgICAgICAgKS5hZGRUbyhtYXBfNjBjMmJmZTE3MzYwNDg4ZWJlOTA4ZWVjZjllNDg2ZjgpOwogICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyX2Q4ZmYzNWVkYTcyMTQ1ODViZGY2OWFjYjY2NjA4OThmID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbMjYuOTAyOTA5MDAwMDAwMDA1LCA3NS44MzY4NTNdLAogICAgICAgICAgICAgICAgeyJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwgImNvbG9yIjogIiMwMDAwMDAiLCAiZGFzaEFycmF5IjogbnVsbCwgImRhc2hPZmZzZXQiOiBudWxsLCAiZmlsbCI6IHRydWUsICJmaWxsQ29sb3IiOiAiI0QzRDNEMyIsICJmaWxsT3BhY2l0eSI6IDEsICJmaWxsUnVsZSI6ICJldmVub2RkIiwgImxpbmVDYXAiOiAicm91bmQiLCAibGluZUpvaW4iOiAicm91bmQiLCAib3BhY2l0eSI6IDEuMCwgInJhZGl1cyI6IDUsICJzdHJva2UiOiB0cnVlLCAid2VpZ2h0IjogM30KICAgICAgICAgICAgKS5hZGRUbyhtYXBfNjBjMmJmZTE3MzYwNDg4ZWJlOTA4ZWVjZjllNDg2ZjgpOwogICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyX2ZhOWY4YjE3NTU1MzQ3MDlhYmYyNjk5ZDVhNjI5MmUxID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbMTYuOTg3Mjg2NywgODEuNzM2MzE3NTk5OTk5OTldLAogICAgICAgICAgICAgICAgeyJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwgImNvbG9yIjogIiMwMDAwMDAiLCAiZGFzaEFycmF5IjogbnVsbCwgImRhc2hPZmZzZXQiOiBudWxsLCAiZmlsbCI6IHRydWUsICJmaWxsQ29sb3IiOiAiI0QzRDNEMyIsICJmaWxsT3BhY2l0eSI6IDEsICJmaWxsUnVsZSI6ICJldmVub2RkIiwgImxpbmVDYXAiOiAicm91bmQiLCAibGluZUpvaW4iOiAicm91bmQiLCAib3BhY2l0eSI6IDEuMCwgInJhZGl1cyI6IDUsICJzdHJva2UiOiB0cnVlLCAid2VpZ2h0IjogM30KICAgICAgICAgICAgKS5hZGRUbyhtYXBfNjBjMmJmZTE3MzYwNDg4ZWJlOTA4ZWVjZjllNDg2ZjgpOwogICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyX2Y2YmZmNjMxZmE0ZTRkYjhiODE4ODNlZjM3ZDQ4MmNhID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbMjUuMzUwNTk4NjAwMDAwMDEsIDgyLjkwODMwNzRdLAogICAgICAgICAgICAgICAgeyJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwgImNvbG9yIjogIiMwMDAwMDAiLCAiZGFzaEFycmF5IjogbnVsbCwgImRhc2hPZmZzZXQiOiBudWxsLCAiZmlsbCI6IHRydWUsICJmaWxsQ29sb3IiOiAiI0QzRDNEMyIsICJmaWxsT3BhY2l0eSI6IDEsICJmaWxsUnVsZSI6ICJldmVub2RkIiwgImxpbmVDYXAiOiAicm91bmQiLCAibGluZUpvaW4iOiAicm91bmQiLCAib3BhY2l0eSI6IDEuMCwgInJhZGl1cyI6IDUsICJzdHJva2UiOiB0cnVlLCAid2VpZ2h0IjogM30KICAgICAgICAgICAgKS5hZGRUbyhtYXBfNjBjMmJmZTE3MzYwNDg4ZWJlOTA4ZWVjZjllNDg2ZjgpOwogICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzQ5NDY2M2Q5OTBjYTQxNDM5YjU0YTUzOGU1ZTNjNGI5ID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbMjMuNjg1Mjk2OTk5OTk5OTk1LCA4Ni45NDU5NjgwMDAwMDAwMV0sCiAgICAgICAgICAgICAgICB7ImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLCAiY29sb3IiOiAiIzAwMDAwMCIsICJkYXNoQXJyYXkiOiBudWxsLCAiZGFzaE9mZnNldCI6IG51bGwsICJmaWxsIjogdHJ1ZSwgImZpbGxDb2xvciI6ICIjRDNEM0QzIiwgImZpbGxPcGFjaXR5IjogMSwgImZpbGxSdWxlIjogImV2ZW5vZGQiLCAibGluZUNhcCI6ICJyb3VuZCIsICJsaW5lSm9pbiI6ICJyb3VuZCIsICJvcGFjaXR5IjogMS4wLCAicmFkaXVzIjogNSwgInN0cm9rZSI6IHRydWUsICJ3ZWlnaHQiOiAzfQogICAgICAgICAgICApLmFkZFRvKG1hcF82MGMyYmZlMTczNjA0ODhlYmU5MDhlZWNmOWU0ODZmOCk7CiAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfY2E5ZTc1NmMwODU5NDY4MjkxMzVkMzBmYmU4Mzc0ZDggPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFsyNC41ODg2MTY1OTk5OTk5OTgsIDczLjYzMjEzOTcwMDAwMDAxXSwKICAgICAgICAgICAgICAgIHsiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsICJjb2xvciI6ICIjMDAwMDAwIiwgImRhc2hBcnJheSI6IG51bGwsICJkYXNoT2Zmc2V0IjogbnVsbCwgImZpbGwiOiB0cnVlLCAiZmlsbENvbG9yIjogIiNEM0QzRDMiLCAiZmlsbE9wYWNpdHkiOiAxLCAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsICJsaW5lQ2FwIjogInJvdW5kIiwgImxpbmVKb2luIjogInJvdW5kIiwgIm9wYWNpdHkiOiAxLjAsICJyYWRpdXMiOiA1LCAic3Ryb2tlIjogdHJ1ZSwgIndlaWdodCI6IDN9CiAgICAgICAgICAgICkuYWRkVG8obWFwXzYwYzJiZmUxNzM2MDQ4OGViZTkwOGVlY2Y5ZTQ4NmY4KTsKICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9mOWM1NDdkZTBmMTA0NGIwOGNjNDMxNmYyMTdhMTdkNiA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzE5LjA0MTg0Njk5OTk5OTk5NywgNzIuODY1NTEyOTk5OTk5OTldLAogICAgICAgICAgICAgICAgeyJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwgImNvbG9yIjogIiMwMDAwMDAiLCAiZGFzaEFycmF5IjogbnVsbCwgImRhc2hPZmZzZXQiOiBudWxsLCAiZmlsbCI6IHRydWUsICJmaWxsQ29sb3IiOiAiI0QzRDNEMyIsICJmaWxsT3BhY2l0eSI6IDEsICJmaWxsUnVsZSI6ICJldmVub2RkIiwgImxpbmVDYXAiOiAicm91bmQiLCAibGluZUpvaW4iOiAicm91bmQiLCAib3BhY2l0eSI6IDEuMCwgInJhZGl1cyI6IDUsICJzdHJva2UiOiB0cnVlLCAid2VpZ2h0IjogM30KICAgICAgICAgICAgKS5hZGRUbyhtYXBfNjBjMmJmZTE3MzYwNDg4ZWJlOTA4ZWVjZjllNDg2ZjgpOwogICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzMxNzU4MWIzMjI5MjQ5NzlhNGI2YjhhODAzMjZjYWU3ID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbMjIuOTY4MjU5MTAwMDAwMDA4LCA3Ni4wNjQxMTgwMDAwMDAwMV0sCiAgICAgICAgICAgICAgICB7ImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLCAiY29sb3IiOiAiIzAwMDAwMCIsICJkYXNoQXJyYXkiOiBudWxsLCAiZGFzaE9mZnNldCI6IG51bGwsICJmaWxsIjogdHJ1ZSwgImZpbGxDb2xvciI6ICIjRDNEM0QzIiwgImZpbGxPcGFjaXR5IjogMSwgImZpbGxSdWxlIjogImV2ZW5vZGQiLCAibGluZUNhcCI6ICJyb3VuZCIsICJsaW5lSm9pbiI6ICJyb3VuZCIsICJvcGFjaXR5IjogMS4wLCAicmFkaXVzIjogNSwgInN0cm9rZSI6IHRydWUsICJ3ZWlnaHQiOiAzfQogICAgICAgICAgICApLmFkZFRvKG1hcF82MGMyYmZlMTczNjA0ODhlYmU5MDhlZWNmOWU0ODZmOCk7CiAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfNmQ2ZGY4MzFmOWRlNGMxM2FlZjY5OWY5MWY4YjgwZmIgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFsxNy41NDA4OTEwMDAwMDAwMDIsIDc4LjM1ODUyOF0sCiAgICAgICAgICAgICAgICB7ImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLCAiY29sb3IiOiAiIzAwMDAwMCIsICJkYXNoQXJyYXkiOiBudWxsLCAiZGFzaE9mZnNldCI6IG51bGwsICJmaWxsIjogdHJ1ZSwgImZpbGxDb2xvciI6ICIjRDNEM0QzIiwgImZpbGxPcGFjaXR5IjogMSwgImZpbGxSdWxlIjogImV2ZW5vZGQiLCAibGluZUNhcCI6ICJyb3VuZCIsICJsaW5lSm9pbiI6ICJyb3VuZCIsICJvcGFjaXR5IjogMS4wLCAicmFkaXVzIjogNSwgInN0cm9rZSI6IHRydWUsICJ3ZWlnaHQiOiAzfQogICAgICAgICAgICApLmFkZFRvKG1hcF82MGMyYmZlMTczNjA0ODhlYmU5MDhlZWNmOWU0ODZmOCk7CiAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfMjlhYjYwOTkxMDVhNDQyY2E2NmY0OTFlZDcxMDRkNjIgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFsyOC43MjU2NTA0MDAwMDAwMDMsIDc3LjIwMTE1NzI5OTk5OTk5XSwKICAgICAgICAgICAgICAgIHsiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsICJjb2xvciI6ICIjMDAwMDAwIiwgImRhc2hBcnJheSI6IG51bGwsICJkYXNoT2Zmc2V0IjogbnVsbCwgImZpbGwiOiB0cnVlLCAiZmlsbENvbG9yIjogIiNEM0QzRDMiLCAiZmlsbE9wYWNpdHkiOiAxLCAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsICJsaW5lQ2FwIjogInJvdW5kIiwgImxpbmVKb2luIjogInJvdW5kIiwgIm9wYWNpdHkiOiAxLjAsICJyYWRpdXMiOiA1LCAic3Ryb2tlIjogdHJ1ZSwgIndlaWdodCI6IDN9CiAgICAgICAgICAgICkuYWRkVG8obWFwXzYwYzJiZmUxNzM2MDQ4OGViZTkwOGVlY2Y5ZTQ4NmY4KTsKICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl82ZGQyNmFlMzdlNGI0ZDFiYjdhMWIzY2QzNmFjNTM1ZCA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzI4LjU1MTIwMDQ5OTk5OTk5NywgNzcuMjczNTczNzAwMDAwMDNdLAogICAgICAgICAgICAgICAgeyJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwgImNvbG9yIjogIiMwMDAwMDAiLCAiZGFzaEFycmF5IjogbnVsbCwgImRhc2hPZmZzZXQiOiBudWxsLCAiZmlsbCI6IHRydWUsICJmaWxsQ29sb3IiOiAiI0QzRDNEMyIsICJmaWxsT3BhY2l0eSI6IDEsICJmaWxsUnVsZSI6ICJldmVub2RkIiwgImxpbmVDYXAiOiAicm91bmQiLCAibGluZUpvaW4iOiAicm91bmQiLCAib3BhY2l0eSI6IDEuMCwgInJhZGl1cyI6IDUsICJzdHJva2UiOiB0cnVlLCAid2VpZ2h0IjogM30KICAgICAgICAgICAgKS5hZGRUbyhtYXBfNjBjMmJmZTE3MzYwNDg4ZWJlOTA4ZWVjZjllNDg2ZjgpOwogICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzNkZWMwYzY4N2Y4MDQ3NGNhZTEzYmFkYzc5OTJhNDU1ID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbMjYuODgyMTAwMjk5OTk5OTk0LCA4MC45MzAyNzUyOTk5OTk5OV0sCiAgICAgICAgICAgICAgICB7ImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLCAiY29sb3IiOiAiIzAwMDAwMCIsICJkYXNoQXJyYXkiOiBudWxsLCAiZGFzaE9mZnNldCI6IG51bGwsICJmaWxsIjogdHJ1ZSwgImZpbGxDb2xvciI6ICIjRDNEM0QzIiwgImZpbGxPcGFjaXR5IjogMSwgImZpbGxSdWxlIjogImV2ZW5vZGQiLCAibGluZUNhcCI6ICJyb3VuZCIsICJsaW5lSm9pbiI6ICJyb3VuZCIsICJvcGFjaXR5IjogMS4wLCAicmFkaXVzIjogNSwgInN0cm9rZSI6IHRydWUsICJ3ZWlnaHQiOiAzfQogICAgICAgICAgICApLmFkZFRvKG1hcF82MGMyYmZlMTczNjA0ODhlYmU5MDhlZWNmOWU0ODZmOCk7CiAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfMjM2NDJhZjM2NjlmNGFhYjk0ODFhNTBjMzQxNjBjMTYgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFsxNy40NjAxMDMsIDc4LjMzNDM2MDk5OTk5OTk5XSwKICAgICAgICAgICAgICAgIHsiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsICJjb2xvciI6ICIjMDAwMDAwIiwgImRhc2hBcnJheSI6IG51bGwsICJkYXNoT2Zmc2V0IjogbnVsbCwgImZpbGwiOiB0cnVlLCAiZmlsbENvbG9yIjogIiNEM0QzRDMiLCAiZmlsbE9wYWNpdHkiOiAxLCAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsICJsaW5lQ2FwIjogInJvdW5kIiwgImxpbmVKb2luIjogInJvdW5kIiwgIm9wYWNpdHkiOiAxLjAsICJyYWRpdXMiOiA1LCAic3Ryb2tlIjogdHJ1ZSwgIndlaWdodCI6IDN9CiAgICAgICAgICAgICkuYWRkVG8obWFwXzYwYzJiZmUxNzM2MDQ4OGViZTkwOGVlY2Y5ZTQ4NmY4KTsKICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl8zNmVjOTU3YzJmNDg0NWEyYjA3YjBiNDAzNjljODFiMiA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzE5LjY0NTMyMzk5OTk5OTk5NSwgNzcuNjM0NTIzMl0sCiAgICAgICAgICAgICAgICB7ImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLCAiY29sb3IiOiAiIzAwMDAwMCIsICJkYXNoQXJyYXkiOiBudWxsLCAiZGFzaE9mZnNldCI6IG51bGwsICJmaWxsIjogdHJ1ZSwgImZpbGxDb2xvciI6ICIjRDNEM0QzIiwgImZpbGxPcGFjaXR5IjogMSwgImZpbGxSdWxlIjogImV2ZW5vZGQiLCAibGluZUNhcCI6ICJyb3VuZCIsICJsaW5lSm9pbiI6ICJyb3VuZCIsICJvcGFjaXR5IjogMS4wLCAicmFkaXVzIjogNSwgInN0cm9rZSI6IHRydWUsICJ3ZWlnaHQiOiAzfQogICAgICAgICAgICApLmFkZFRvKG1hcF82MGMyYmZlMTczNjA0ODhlYmU5MDhlZWNmOWU0ODZmOCk7CiAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfNTAyMDk4NzExNjJlNDMwYTlhOTQ1YzUyZTNjMWU4YzEgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFszMS4zMjE5MDcwMDAwMDAwMDcsIDc1LjU3ODkxMzk5OTk5OTk4XSwKICAgICAgICAgICAgICAgIHsiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsICJjb2xvciI6ICIjMDAwMDAwIiwgImRhc2hBcnJheSI6IG51bGwsICJkYXNoT2Zmc2V0IjogbnVsbCwgImZpbGwiOiB0cnVlLCAiZmlsbENvbG9yIjogIiNEM0QzRDMiLCAiZmlsbE9wYWNpdHkiOiAxLCAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsICJsaW5lQ2FwIjogInJvdW5kIiwgImxpbmVKb2luIjogInJvdW5kIiwgIm9wYWNpdHkiOiAxLjAsICJyYWRpdXMiOiA1LCAic3Ryb2tlIjogdHJ1ZSwgIndlaWdodCI6IDN9CiAgICAgICAgICAgICkuYWRkVG8obWFwXzYwYzJiZmUxNzM2MDQ4OGViZTkwOGVlY2Y5ZTQ4NmY4KTsKICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9mM2FlNWI2YjJmMDM0MTQ1YjE4MzkyODk1YTBkODU0YyA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzI2LjI2ODI0ODk5OTk5OTk5NywgNzMuMDE5Mzg1Mjk5OTk5OThdLAogICAgICAgICAgICAgICAgeyJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwgImNvbG9yIjogIiMwMDAwMDAiLCAiZGFzaEFycmF5IjogbnVsbCwgImRhc2hPZmZzZXQiOiBudWxsLCAiZmlsbCI6IHRydWUsICJmaWxsQ29sb3IiOiAiI0QzRDNEMyIsICJmaWxsT3BhY2l0eSI6IDEsICJmaWxsUnVsZSI6ICJldmVub2RkIiwgImxpbmVDYXAiOiAicm91bmQiLCAibGluZUpvaW4iOiAicm91bmQiLCAib3BhY2l0eSI6IDEuMCwgInJhZGl1cyI6IDUsICJzdHJva2UiOiB0cnVlLCAid2VpZ2h0IjogM30KICAgICAgICAgICAgKS5hZGRUbyhtYXBfNjBjMmJmZTE3MzYwNDg4ZWJlOTA4ZWVjZjllNDg2ZjgpOwogICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzk0ZTU4ZThhZjZiODRkYTA4MjU2ZTJiNDE0MWQwZTdiID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbMjguNzUwMDQ5OTAwMDAwMDA0LCA3Ny4xMTEyNjE0OTk5OTk5OF0sCiAgICAgICAgICAgICAgICB7ImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLCAiY29sb3IiOiAiIzAwMDAwMCIsICJkYXNoQXJyYXkiOiBudWxsLCAiZGFzaE9mZnNldCI6IG51bGwsICJmaWxsIjogdHJ1ZSwgImZpbGxDb2xvciI6ICIjRDNEM0QzIiwgImZpbGxPcGFjaXR5IjogMSwgImZpbGxSdWxlIjogImV2ZW5vZGQiLCAibGluZUNhcCI6ICJyb3VuZCIsICJsaW5lSm9pbiI6ICJyb3VuZCIsICJvcGFjaXR5IjogMS4wLCAicmFkaXVzIjogNSwgInN0cm9rZSI6IHRydWUsICJ3ZWlnaHQiOiAzfQogICAgICAgICAgICApLmFkZFRvKG1hcF82MGMyYmZlMTczNjA0ODhlYmU5MDhlZWNmOWU0ODZmOCk7CiAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfMDc1YTAxZmEzNzRhNGMxNjk0ZjFhZjg2ZjE4ODA0MGQgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFsyMS44MDA0OTk2LCA4My44Mzk2OTc3XSwKICAgICAgICAgICAgICAgIHsiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsICJjb2xvciI6ICIjMDAwMDAwIiwgImRhc2hBcnJheSI6IG51bGwsICJkYXNoT2Zmc2V0IjogbnVsbCwgImZpbGwiOiB0cnVlLCAiZmlsbENvbG9yIjogIiNEM0QzRDMiLCAiZmlsbE9wYWNpdHkiOiAxLCAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsICJsaW5lQ2FwIjogInJvdW5kIiwgImxpbmVKb2luIjogInJvdW5kIiwgIm9wYWNpdHkiOiAxLjAsICJyYWRpdXMiOiA1LCAic3Ryb2tlIjogdHJ1ZSwgIndlaWdodCI6IDN9CiAgICAgICAgICAgICkuYWRkVG8obWFwXzYwYzJiZmUxNzM2MDQ4OGViZTkwOGVlY2Y5ZTQ4NmY4KTsKICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9kOWFmOTg3NDYwYTQ0ZDJhOTc4YTI1YWNiYjhjNzY0MSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzE3LjcyLCA4My4yOTk5OTk5OTk5OTk5OF0sCiAgICAgICAgICAgICAgICB7ImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLCAiY29sb3IiOiAiIzAwMDAwMCIsICJkYXNoQXJyYXkiOiBudWxsLCAiZGFzaE9mZnNldCI6IG51bGwsICJmaWxsIjogdHJ1ZSwgImZpbGxDb2xvciI6ICIjRDNEM0QzIiwgImZpbGxPcGFjaXR5IjogMSwgImZpbGxSdWxlIjogImV2ZW5vZGQiLCAibGluZUNhcCI6ICJyb3VuZCIsICJsaW5lSm9pbiI6ICJyb3VuZCIsICJvcGFjaXR5IjogMS4wLCAicmFkaXVzIjogNSwgInN0cm9rZSI6IHRydWUsICJ3ZWlnaHQiOiAzfQogICAgICAgICAgICApLmFkZFRvKG1hcF82MGMyYmZlMTczNjA0ODhlYmU5MDhlZWNmOWU0ODZmOCk7CiAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfY2VmMTFjMjhhZTg2NDNkMDk0NmI3OGU1YTk0NzcxOTYgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFsyMC4wMDczMjg1LCA3My43NzYyNDI3XSwKICAgICAgICAgICAgICAgIHsiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsICJjb2xvciI6ICIjMDAwMDAwIiwgImRhc2hBcnJheSI6IG51bGwsICJkYXNoT2Zmc2V0IjogbnVsbCwgImZpbGwiOiB0cnVlLCAiZmlsbENvbG9yIjogIiNEM0QzRDMiLCAiZmlsbE9wYWNpdHkiOiAxLCAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsICJsaW5lQ2FwIjogInJvdW5kIiwgImxpbmVKb2luIjogInJvdW5kIiwgIm9wYWNpdHkiOiAxLjAsICJyYWRpdXMiOiA1LCAic3Ryb2tlIjogdHJ1ZSwgIndlaWdodCI6IDN9CiAgICAgICAgICAgICkuYWRkVG8obWFwXzYwYzJiZmUxNzM2MDQ4OGViZTkwOGVlY2Y5ZTQ4NmY4KTsKICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9jNTgyZjljMjNhYjc0YzJmOTEyMjE5NzcxYTkyNzg5YSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzMxLjYyLCA3NC44NzY1MTIwMDAwMDAwMl0sCiAgICAgICAgICAgICAgICB7ImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLCAiY29sb3IiOiAiIzAwMDAwMCIsICJkYXNoQXJyYXkiOiBudWxsLCAiZGFzaE9mZnNldCI6IG51bGwsICJmaWxsIjogdHJ1ZSwgImZpbGxDb2xvciI6ICIjRDNEM0QzIiwgImZpbGxPcGFjaXR5IjogMSwgImZpbGxSdWxlIjogImV2ZW5vZGQiLCAibGluZUNhcCI6ICJyb3VuZCIsICJsaW5lSm9pbiI6ICJyb3VuZCIsICJvcGFjaXR5IjogMS4wLCAicmFkaXVzIjogNSwgInN0cm9rZSI6IHRydWUsICJ3ZWlnaHQiOiAzfQogICAgICAgICAgICApLmFkZFRvKG1hcF82MGMyYmZlMTczNjA0ODhlYmU5MDhlZWNmOWU0ODZmOCk7CiAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfZWE5OWU5NzVlNDI2NDljMTk0ZmQ5ZTFmMGRjM2ZkZmYgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFsxNy40MzQyMzU5LCA3OC40MTcwMzE4XSwKICAgICAgICAgICAgICAgIHsiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsICJjb2xvciI6ICIjMDAwMDAwIiwgImRhc2hBcnJheSI6IG51bGwsICJkYXNoT2Zmc2V0IjogbnVsbCwgImZpbGwiOiB0cnVlLCAiZmlsbENvbG9yIjogIiNEM0QzRDMiLCAiZmlsbE9wYWNpdHkiOiAxLCAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsICJsaW5lQ2FwIjogInJvdW5kIiwgImxpbmVKb2luIjogInJvdW5kIiwgIm9wYWNpdHkiOiAxLjAsICJyYWRpdXMiOiA1LCAic3Ryb2tlIjogdHJ1ZSwgIndlaWdodCI6IDN9CiAgICAgICAgICAgICkuYWRkVG8obWFwXzYwYzJiZmUxNzM2MDQ4OGViZTkwOGVlY2Y5ZTQ4NmY4KTsKICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl84YTk0Yjg2ZGY0NDE0NzQwOTkyZjVlNjljM2FhMjE2MyA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzE3LjUzMTY4OTUsIDc4LjIxODkzODk5OTk5OTk5XSwKICAgICAgICAgICAgICAgIHsiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsICJjb2xvciI6ICIjMDAwMDAwIiwgImRhc2hBcnJheSI6IG51bGwsICJkYXNoT2Zmc2V0IjogbnVsbCwgImZpbGwiOiB0cnVlLCAiZmlsbENvbG9yIjogIiNEM0QzRDMiLCAiZmlsbE9wYWNpdHkiOiAxLCAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsICJsaW5lQ2FwIjogInJvdW5kIiwgImxpbmVKb2luIjogInJvdW5kIiwgIm9wYWNpdHkiOiAxLjAsICJyYWRpdXMiOiA1LCAic3Ryb2tlIjogdHJ1ZSwgIndlaWdodCI6IDN9CiAgICAgICAgICAgICkuYWRkVG8obWFwXzYwYzJiZmUxNzM2MDQ4OGViZTkwOGVlY2Y5ZTQ4NmY4KTsKICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9jZjU4ZTdhOThiZTE0MTQ3ODIwZjBmYjBiNjg3ZmQzNCA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzI4LjU2Mjc3NjMsIDc3LjExODAwNTMwMDAwMDAxXSwKICAgICAgICAgICAgICAgIHsiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsICJjb2xvciI6ICIjMDAwMDAwIiwgImRhc2hBcnJheSI6IG51bGwsICJkYXNoT2Zmc2V0IjogbnVsbCwgImZpbGwiOiB0cnVlLCAiZmlsbENvbG9yIjogIiNEM0QzRDMiLCAiZmlsbE9wYWNpdHkiOiAxLCAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsICJsaW5lQ2FwIjogInJvdW5kIiwgImxpbmVKb2luIjogInJvdW5kIiwgIm9wYWNpdHkiOiAxLjAsICJyYWRpdXMiOiA1LCAic3Ryb2tlIjogdHJ1ZSwgIndlaWdodCI6IDN9CiAgICAgICAgICAgICkuYWRkVG8obWFwXzYwYzJiZmUxNzM2MDQ4OGViZTkwOGVlY2Y5ZTQ4NmY4KTsKICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl80NzhkY2E2ZjRjNGM0MDIzYWFhYTExYTkwZDg2MmUxYiA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzI1LjU5NDEsIDg1LjEzNzZdLAogICAgICAgICAgICAgICAgeyJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwgImNvbG9yIjogIiMwMDAwMDAiLCAiZGFzaEFycmF5IjogbnVsbCwgImRhc2hPZmZzZXQiOiBudWxsLCAiZmlsbCI6IHRydWUsICJmaWxsQ29sb3IiOiAiI0QzRDNEMyIsICJmaWxsT3BhY2l0eSI6IDEsICJmaWxsUnVsZSI6ICJldmVub2RkIiwgImxpbmVDYXAiOiAicm91bmQiLCAibGluZUpvaW4iOiAicm91bmQiLCAib3BhY2l0eSI6IDEuMCwgInJhZGl1cyI6IDUsICJzdHJva2UiOiB0cnVlLCAid2VpZ2h0IjogM30KICAgICAgICAgICAgKS5hZGRUbyhtYXBfNjBjMmJmZTE3MzYwNDg4ZWJlOTA4ZWVjZjllNDg2ZjgpOwogICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyX2JhN2UyMDNiNzExYjQyMjBiOWVhZWY3NzE3NDc2Y2NlID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbMjguNjgwMjc0Njk5OTk5OTg4LCA3Ny4yMDExNTcyOTk5OTk5OV0sCiAgICAgICAgICAgICAgICB7ImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLCAiY29sb3IiOiAiIzAwMDAwMCIsICJkYXNoQXJyYXkiOiBudWxsLCAiZGFzaE9mZnNldCI6IG51bGwsICJmaWxsIjogdHJ1ZSwgImZpbGxDb2xvciI6ICIjRDNEM0QzIiwgImZpbGxPcGFjaXR5IjogMSwgImZpbGxSdWxlIjogImV2ZW5vZGQiLCAibGluZUNhcCI6ICJyb3VuZCIsICJsaW5lSm9pbiI6ICJyb3VuZCIsICJvcGFjaXR5IjogMS4wLCAicmFkaXVzIjogNSwgInN0cm9rZSI6IHRydWUsICJ3ZWlnaHQiOiAzfQogICAgICAgICAgICApLmFkZFRvKG1hcF82MGMyYmZlMTczNjA0ODhlYmU5MDhlZWNmOWU0ODZmOCk7CiAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfY2Y4OTAzN2E3YjhhNDI5ODg3N2YyOTRlZTVhODVmNjcgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFsxMy4wMDUyMTg4OTk5OTk5OTcsIDgwLjIzOTgxMjQ5OTk5OTk5XSwKICAgICAgICAgICAgICAgIHsiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsICJjb2xvciI6ICIjMDAwMDAwIiwgImRhc2hBcnJheSI6IG51bGwsICJkYXNoT2Zmc2V0IjogbnVsbCwgImZpbGwiOiB0cnVlLCAiZmlsbENvbG9yIjogIiNEM0QzRDMiLCAiZmlsbE9wYWNpdHkiOiAxLCAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsICJsaW5lQ2FwIjogInJvdW5kIiwgImxpbmVKb2luIjogInJvdW5kIiwgIm9wYWNpdHkiOiAxLjAsICJyYWRpdXMiOiA1LCAic3Ryb2tlIjogdHJ1ZSwgIndlaWdodCI6IDN9CiAgICAgICAgICAgICkuYWRkVG8obWFwXzYwYzJiZmUxNzM2MDQ4OGViZTkwOGVlY2Y5ZTQ4NmY4KTsKICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl85ZTAxYzJiNzM4Zjk0M2QwYjk5YzBmM2JjYzVkNTM2ZCA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzI4LjYzMTY5NDUsIDc3LjI0OTQzODcwMDAwMDAxXSwKICAgICAgICAgICAgICAgIHsiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsICJjb2xvciI6ICIjMDAwMDAwIiwgImRhc2hBcnJheSI6IG51bGwsICJkYXNoT2Zmc2V0IjogbnVsbCwgImZpbGwiOiB0cnVlLCAiZmlsbENvbG9yIjogIiNEM0QzRDMiLCAiZmlsbE9wYWNpdHkiOiAxLCAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsICJsaW5lQ2FwIjogInJvdW5kIiwgImxpbmVKb2luIjogInJvdW5kIiwgIm9wYWNpdHkiOiAxLjAsICJyYWRpdXMiOiA1LCAic3Ryb2tlIjogdHJ1ZSwgIndlaWdodCI6IDN9CiAgICAgICAgICAgICkuYWRkVG8obWFwXzYwYzJiZmUxNzM2MDQ4OGViZTkwOGVlY2Y5ZTQ4NmY4KTsKICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl8zNWFlNDExNjhiYWM0YzQ0ODNlMTkzMzE4NGJmYWI0OSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzI1Ljc3MTA2MDk5OTk5OTk5MiwgNzMuMzQwMjI3MDAwMDAwMDFdLAogICAgICAgICAgICAgICAgeyJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwgImNvbG9yIjogIiMwMDAwMDAiLCAiZGFzaEFycmF5IjogbnVsbCwgImRhc2hPZmZzZXQiOiBudWxsLCAiZmlsbCI6IHRydWUsICJmaWxsQ29sb3IiOiAiI0QzRDNEMyIsICJmaWxsT3BhY2l0eSI6IDEsICJmaWxsUnVsZSI6ICJldmVub2RkIiwgImxpbmVDYXAiOiAicm91bmQiLCAibGluZUpvaW4iOiAicm91bmQiLCAib3BhY2l0eSI6IDEuMCwgInJhZGl1cyI6IDUsICJzdHJva2UiOiB0cnVlLCAid2VpZ2h0IjogM30KICAgICAgICAgICAgKS5hZGRUbyhtYXBfNjBjMmJmZTE3MzYwNDg4ZWJlOTA4ZWVjZjllNDg2ZjgpOwogICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzg3Nzk2NjRmOWYwODQ4ZTNhZDM3NTdkOWQzMzUwYmYzID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbMTguNTAxMTc0MzAwMDAwMDAyLCA3My44MTY1NTI3XSwKICAgICAgICAgICAgICAgIHsiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsICJjb2xvciI6ICIjMDAwMDAwIiwgImRhc2hBcnJheSI6IG51bGwsICJkYXNoT2Zmc2V0IjogbnVsbCwgImZpbGwiOiB0cnVlLCAiZmlsbENvbG9yIjogIiNEM0QzRDMiLCAiZmlsbE9wYWNpdHkiOiAxLCAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsICJsaW5lQ2FwIjogInJvdW5kIiwgImxpbmVKb2luIjogInJvdW5kIiwgIm9wYWNpdHkiOiAxLjAsICJyYWRpdXMiOiA1LCAic3Ryb2tlIjogdHJ1ZSwgIndlaWdodCI6IDN9CiAgICAgICAgICAgICkuYWRkVG8obWFwXzYwYzJiZmUxNzM2MDQ4OGViZTkwOGVlY2Y5ZTQ4NmY4KTsKICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl84YWJlZWFhMjk4MGU0NDg0OWY2ODY4MWViMGE1MjE2ZSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzI4LjgyNTM0MDk5OTk5OTk5OCwgNzguNzIxMzAwOV0sCiAgICAgICAgICAgICAgICB7ImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLCAiY29sb3IiOiAiIzAwMDAwMCIsICJkYXNoQXJyYXkiOiBudWxsLCAiZGFzaE9mZnNldCI6IG51bGwsICJmaWxsIjogdHJ1ZSwgImZpbGxDb2xvciI6ICIjRDNEM0QzIiwgImZpbGxPcGFjaXR5IjogMSwgImZpbGxSdWxlIjogImV2ZW5vZGQiLCAibGluZUNhcCI6ICJyb3VuZCIsICJsaW5lSm9pbiI6ICJyb3VuZCIsICJvcGFjaXR5IjogMS4wLCAicmFkaXVzIjogNSwgInN0cm9rZSI6IHRydWUsICJ3ZWlnaHQiOiAzfQogICAgICAgICAgICApLmFkZFRvKG1hcF82MGMyYmZlMTczNjA0ODhlYmU5MDhlZWNmOWU0ODZmOCk7CiAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfZjQ0Y2E2YWYwYTMxNDA3NGJkOTU2YjRiZDE0ZWVhOTkgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFsyNi44NDU4ODA1MDAwMDAwMDMsIDgwLjkzNjU1NDA5OTk5OTk4XSwKICAgICAgICAgICAgICAgIHsiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsICJjb2xvciI6ICIjMDAwMDAwIiwgImRhc2hBcnJheSI6IG51bGwsICJkYXNoT2Zmc2V0IjogbnVsbCwgImZpbGwiOiB0cnVlLCAiZmlsbENvbG9yIjogIiNEM0QzRDMiLCAiZmlsbE9wYWNpdHkiOiAxLCAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsICJsaW5lQ2FwIjogInJvdW5kIiwgImxpbmVKb2luIjogInJvdW5kIiwgIm9wYWNpdHkiOiAxLjAsICJyYWRpdXMiOiA1LCAic3Ryb2tlIjogdHJ1ZSwgIndlaWdodCI6IDN9CiAgICAgICAgICAgICkuYWRkVG8obWFwXzYwYzJiZmUxNzM2MDQ4OGViZTkwOGVlY2Y5ZTQ4NmY4KTsKICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl82NWZkMDc2MzhkMjY0ZDRkOGViOWYwMDlhZmNiNGQ3MCA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzI4LjU5MTgyNDUwMDAwMDAxMiwgNzcuMjI3MzA3Mzk5OTk5OTldLAogICAgICAgICAgICAgICAgeyJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwgImNvbG9yIjogIiMwMDAwMDAiLCAiZGFzaEFycmF5IjogbnVsbCwgImRhc2hPZmZzZXQiOiBudWxsLCAiZmlsbCI6IHRydWUsICJmaWxsQ29sb3IiOiAiI0QzRDNEMyIsICJmaWxsT3BhY2l0eSI6IDEsICJmaWxsUnVsZSI6ICJldmVub2RkIiwgImxpbmVDYXAiOiAicm91bmQiLCAibGluZUpvaW4iOiAicm91bmQiLCAib3BhY2l0eSI6IDEuMCwgInJhZGl1cyI6IDUsICJzdHJva2UiOiB0cnVlLCAid2VpZ2h0IjogM30KICAgICAgICAgICAgKS5hZGRUbyhtYXBfNjBjMmJmZTE3MzYwNDg4ZWJlOTA4ZWVjZjllNDg2ZjgpOwogICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzZiOTczMzZmYThlYzQ2YWVhMGNkZDU2YjA1MDdjMjMwID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbMjMuMTgyNzE4OTk5OTk5OTk1LCA3NS43NjgyMTgwMDAwMDAwMl0sCiAgICAgICAgICAgICAgICB7ImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLCAiY29sb3IiOiAiIzAwMDAwMCIsICJkYXNoQXJyYXkiOiBudWxsLCAiZGFzaE9mZnNldCI6IG51bGwsICJmaWxsIjogdHJ1ZSwgImZpbGxDb2xvciI6ICIjRDNEM0QzIiwgImZpbGxPcGFjaXR5IjogMSwgImZpbGxSdWxlIjogImV2ZW5vZGQiLCAibGluZUNhcCI6ICJyb3VuZCIsICJsaW5lSm9pbiI6ICJyb3VuZCIsICJvcGFjaXR5IjogMS4wLCAicmFkaXVzIjogNSwgInN0cm9rZSI6IHRydWUsICJ3ZWlnaHQiOiAzfQogICAgICAgICAgICApLmFkZFRvKG1hcF82MGMyYmZlMTczNjA0ODhlYmU5MDhlZWNmOWU0ODZmOCk7CiAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfNDk2MDNjMjhmNGVjNGMzY2IxMzc0MjE3ZDExNDJkMWMgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFsxMy4xNjQ1NDQwMDAwMDAwMDUsIDgwLjI2Mjg0OTk5OTk5OTk5XSwKICAgICAgICAgICAgICAgIHsiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsICJjb2xvciI6ICIjMDAwMDAwIiwgImRhc2hBcnJheSI6IG51bGwsICJkYXNoT2Zmc2V0IjogbnVsbCwgImZpbGwiOiB0cnVlLCAiZmlsbENvbG9yIjogIiNEM0QzRDMiLCAiZmlsbE9wYWNpdHkiOiAxLCAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsICJsaW5lQ2FwIjogInJvdW5kIiwgImxpbmVKb2luIjogInJvdW5kIiwgIm9wYWNpdHkiOiAxLjAsICJyYWRpdXMiOiA1LCAic3Ryb2tlIjogdHJ1ZSwgIndlaWdodCI6IDN9CiAgICAgICAgICAgICkuYWRkVG8obWFwXzYwYzJiZmUxNzM2MDQ4OGViZTkwOGVlY2Y5ZTQ4NmY4KTsKICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl84YjcwYmZhMTRhNDA0MzA3YWFhYzU3NmE2NDNhYzYwMyA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzI4LjYzNzI2ODgwMDAwMDAwNSwgNzcuMjAwNTYwNF0sCiAgICAgICAgICAgICAgICB7ImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLCAiY29sb3IiOiAiIzAwMDAwMCIsICJkYXNoQXJyYXkiOiBudWxsLCAiZGFzaE9mZnNldCI6IG51bGwsICJmaWxsIjogdHJ1ZSwgImZpbGxDb2xvciI6ICIjRDNEM0QzIiwgImZpbGxPcGFjaXR5IjogMSwgImZpbGxSdWxlIjogImV2ZW5vZGQiLCAibGluZUNhcCI6ICJyb3VuZCIsICJsaW5lSm9pbiI6ICJyb3VuZCIsICJvcGFjaXR5IjogMS4wLCAicmFkaXVzIjogNSwgInN0cm9rZSI6IHRydWUsICJ3ZWlnaHQiOiAzfQogICAgICAgICAgICApLmFkZFRvKG1hcF82MGMyYmZlMTczNjA0ODhlYmU5MDhlZWNmOWU0ODZmOCk7CiAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfYzhkOTU1MzYwN2U3NGMxMmFjMGMyZTBlN2ZjMTY5OWIgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFsyMy4wMDI2NTcsIDcyLjU5MTkxMl0sCiAgICAgICAgICAgICAgICB7ImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLCAiY29sb3IiOiAiIzAwMDAwMCIsICJkYXNoQXJyYXkiOiBudWxsLCAiZGFzaE9mZnNldCI6IG51bGwsICJmaWxsIjogdHJ1ZSwgImZpbGxDb2xvciI6ICIjRDNEM0QzIiwgImZpbGxPcGFjaXR5IjogMSwgImZpbGxSdWxlIjogImV2ZW5vZGQiLCAibGluZUNhcCI6ICJyb3VuZCIsICJsaW5lSm9pbiI6ICJyb3VuZCIsICJvcGFjaXR5IjogMS4wLCAicmFkaXVzIjogNSwgInN0cm9rZSI6IHRydWUsICJ3ZWlnaHQiOiAzfQogICAgICAgICAgICApLmFkZFRvKG1hcF82MGMyYmZlMTczNjA0ODhlYmU5MDhlZWNmOWU0ODZmOCk7CiAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfNDNkMjg1NzNiMDExNDliY2FmMTIzODE1Y2M1NTU0N2QgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFszMC4zNDkzODgsIDc2LjM2NjY0Ml0sCiAgICAgICAgICAgICAgICB7ImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLCAiY29sb3IiOiAiIzAwMDAwMCIsICJkYXNoQXJyYXkiOiBudWxsLCAiZGFzaE9mZnNldCI6IG51bGwsICJmaWxsIjogdHJ1ZSwgImZpbGxDb2xvciI6ICIjRDNEM0QzIiwgImZpbGxPcGFjaXR5IjogMSwgImZpbGxSdWxlIjogImV2ZW5vZGQiLCAibGluZUNhcCI6ICJyb3VuZCIsICJsaW5lSm9pbiI6ICJyb3VuZCIsICJvcGFjaXR5IjogMS4wLCAicmFkaXVzIjogNSwgInN0cm9rZSI6IHRydWUsICJ3ZWlnaHQiOiAzfQogICAgICAgICAgICApLmFkZFRvKG1hcF82MGMyYmZlMTczNjA0ODhlYmU5MDhlZWNmOWU0ODZmOCk7CiAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfOWFhMmRlZjZmZmJmNDNjZGJjMTJmMzhjMmMxYjAwMTYgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFsxOS44Mzg5NDM5LCA3NS4yNDQ0NDhdLAogICAgICAgICAgICAgICAgeyJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwgImNvbG9yIjogIiMwMDAwMDAiLCAiZGFzaEFycmF5IjogbnVsbCwgImRhc2hPZmZzZXQiOiBudWxsLCAiZmlsbCI6IHRydWUsICJmaWxsQ29sb3IiOiAiI0QzRDNEMyIsICJmaWxsT3BhY2l0eSI6IDEsICJmaWxsUnVsZSI6ICJldmVub2RkIiwgImxpbmVDYXAiOiAicm91bmQiLCAibGluZUpvaW4iOiAicm91bmQiLCAib3BhY2l0eSI6IDEuMCwgInJhZGl1cyI6IDUsICJzdHJva2UiOiB0cnVlLCAid2VpZ2h0IjogM30KICAgICAgICAgICAgKS5hZGRUbyhtYXBfNjBjMmJmZTE3MzYwNDg4ZWJlOTA4ZWVjZjllNDg2ZjgpOwogICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyX2QxYWYxY2ZmZjNhYzRmZmRhNmNhNGI4ODJmNGMxY2Q5ID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbMjYuMTIwOTAwMDAwMDAwMDAyLCA4NS4zNjQ2OTk5OTk5OTk5OF0sCiAgICAgICAgICAgICAgICB7ImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLCAiY29sb3IiOiAiIzAwMDAwMCIsICJkYXNoQXJyYXkiOiBudWxsLCAiZGFzaE9mZnNldCI6IG51bGwsICJmaWxsIjogdHJ1ZSwgImZpbGxDb2xvciI6ICIjRDNEM0QzIiwgImZpbGxPcGFjaXR5IjogMSwgImZpbGxSdWxlIjogImV2ZW5vZGQiLCAibGluZUNhcCI6ICJyb3VuZCIsICJsaW5lSm9pbiI6ICJyb3VuZCIsICJvcGFjaXR5IjogMS4wLCAicmFkaXVzIjogNSwgInN0cm9rZSI6IHRydWUsICJ3ZWlnaHQiOiAzfQogICAgICAgICAgICApLmFkZFRvKG1hcF82MGMyYmZlMTczNjA0ODhlYmU5MDhlZWNmOWU0ODZmOCk7CiAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfMWRjMDg5MDZhZjBmNDUwNjk1YzhjYzc1ZjE0MmE3NTggPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFsyOC42MDkwOSwgNzcuMDMyNTQxM10sCiAgICAgICAgICAgICAgICB7ImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLCAiY29sb3IiOiAiIzAwMDAwMCIsICJkYXNoQXJyYXkiOiBudWxsLCAiZGFzaE9mZnNldCI6IG51bGwsICJmaWxsIjogdHJ1ZSwgImZpbGxDb2xvciI6ICIjRDNEM0QzIiwgImZpbGxPcGFjaXR5IjogMSwgImZpbGxSdWxlIjogImV2ZW5vZGQiLCAibGluZUNhcCI6ICJyb3VuZCIsICJsaW5lSm9pbiI6ICJyb3VuZCIsICJvcGFjaXR5IjogMS4wLCAicmFkaXVzIjogNSwgInN0cm9rZSI6IHRydWUsICJ3ZWlnaHQiOiAzfQogICAgICAgICAgICApLmFkZFRvKG1hcF82MGMyYmZlMTczNjA0ODhlYmU5MDhlZWNmOWU0ODZmOCk7CiAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfMjNkMGRkODE2NWE3NDQxMGE3ZjQ3YzljZDY5NmQwYjkgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFsyNi40NzAzMTM2LCA4MC4zMjI5ODYzMDAwMDAwMV0sCiAgICAgICAgICAgICAgICB7ImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLCAiY29sb3IiOiAiIzAwMDAwMCIsICJkYXNoQXJyYXkiOiBudWxsLCAiZGFzaE9mZnNldCI6IG51bGwsICJmaWxsIjogdHJ1ZSwgImZpbGxDb2xvciI6ICIjRDNEM0QzIiwgImZpbGxPcGFjaXR5IjogMSwgImZpbGxSdWxlIjogImV2ZW5vZGQiLCAibGluZUNhcCI6ICJyb3VuZCIsICJsaW5lSm9pbiI6ICJyb3VuZCIsICJvcGFjaXR5IjogMS4wLCAicmFkaXVzIjogNSwgInN0cm9rZSI6IHRydWUsICJ3ZWlnaHQiOiAzfQogICAgICAgICAgICApLmFkZFRvKG1hcF82MGMyYmZlMTczNjA0ODhlYmU5MDhlZWNmOWU0ODZmOCk7CiAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfYTI3MGY2NTZkODIzNDUwODg0ZGFkOWRjNzYwMzliMWMgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFsyNi44NzE0Mjc5OTk5OTk5OTgsIDgwLjk1NzE0NDk5OTk5OTk4XSwKICAgICAgICAgICAgICAgIHsiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsICJjb2xvciI6ICIjMDAwMDAwIiwgImRhc2hBcnJheSI6IG51bGwsICJkYXNoT2Zmc2V0IjogbnVsbCwgImZpbGwiOiB0cnVlLCAiZmlsbENvbG9yIjogIiNEM0QzRDMiLCAiZmlsbE9wYWNpdHkiOiAxLCAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsICJsaW5lQ2FwIjogInJvdW5kIiwgImxpbmVKb2luIjogInJvdW5kIiwgIm9wYWNpdHkiOiAxLjAsICJyYWRpdXMiOiA1LCAic3Ryb2tlIjogdHJ1ZSwgIndlaWdodCI6IDN9CiAgICAgICAgICAgICkuYWRkVG8obWFwXzYwYzJiZmUxNzM2MDQ4OGViZTkwOGVlY2Y5ZTQ4NmY4KTsKICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9lYTc0Y2VhY2IxMzk0ZjQzOWIxMGRiMTk3NTM5ZjkzMCA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzI4LjY1NzM4MTQwMDAwMDAwNiwgNzcuMTU4NTQ0NzAwMDAwMDFdLAogICAgICAgICAgICAgICAgeyJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwgImNvbG9yIjogIiMwMDAwMDAiLCAiZGFzaEFycmF5IjogbnVsbCwgImRhc2hPZmZzZXQiOiBudWxsLCAiZmlsbCI6IHRydWUsICJmaWxsQ29sb3IiOiAiI0QzRDNEMyIsICJmaWxsT3BhY2l0eSI6IDEsICJmaWxsUnVsZSI6ICJldmVub2RkIiwgImxpbmVDYXAiOiAicm91bmQiLCAibGluZUpvaW4iOiAicm91bmQiLCAib3BhY2l0eSI6IDEuMCwgInJhZGl1cyI6IDUsICJzdHJva2UiOiB0cnVlLCAid2VpZ2h0IjogM30KICAgICAgICAgICAgKS5hZGRUbyhtYXBfNjBjMmJmZTE3MzYwNDg4ZWJlOTA4ZWVjZjllNDg2ZjgpOwogICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyX2RmMjc4M2I1OGZjYTQ1ODE4MGM4OTlhZjk2YzRhMTZhID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbMjEuMTUyODc0OTk5OTk5OTk4LCA3OS4wNTE3NTMxMDAwMDAwMV0sCiAgICAgICAgICAgICAgICB7ImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLCAiY29sb3IiOiAiIzAwMDAwMCIsICJkYXNoQXJyYXkiOiBudWxsLCAiZGFzaE9mZnNldCI6IG51bGwsICJmaWxsIjogdHJ1ZSwgImZpbGxDb2xvciI6ICIjRDNEM0QzIiwgImZpbGxPcGFjaXR5IjogMSwgImZpbGxSdWxlIjogImV2ZW5vZGQiLCAibGluZUNhcCI6ICJyb3VuZCIsICJsaW5lSm9pbiI6ICJyb3VuZCIsICJvcGFjaXR5IjogMS4wLCAicmFkaXVzIjogNSwgInN0cm9rZSI6IHRydWUsICJ3ZWlnaHQiOiAzfQogICAgICAgICAgICApLmFkZFRvKG1hcF82MGMyYmZlMTczNjA0ODhlYmU5MDhlZWNmOWU0ODZmOCk7CiAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfNDAxYTljZTc5ZjlmNGMxYWEyNGE3NjQ4MTIxODIzYzIgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFsyMi41Njg3MzE4OTk5OTk5OTIsIDg4LjI3OTcyNzZdLAogICAgICAgICAgICAgICAgeyJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwgImNvbG9yIjogIiMwMDAwMDAiLCAiZGFzaEFycmF5IjogbnVsbCwgImRhc2hPZmZzZXQiOiBudWxsLCAiZmlsbCI6IHRydWUsICJmaWxsQ29sb3IiOiAiI0QzRDNEMyIsICJmaWxsT3BhY2l0eSI6IDEsICJmaWxsUnVsZSI6ICJldmVub2RkIiwgImxpbmVDYXAiOiAicm91bmQiLCAibGluZUpvaW4iOiAicm91bmQiLCAib3BhY2l0eSI6IDEuMCwgInJhZGl1cyI6IDUsICJzdHJva2UiOiB0cnVlLCAid2VpZ2h0IjogM30KICAgICAgICAgICAgKS5hZGRUbyhtYXBfNjBjMmJmZTE3MzYwNDg4ZWJlOTA4ZWVjZjllNDg2ZjgpOwogICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzlmMzNmMTU4NTQ0MTQ3OGQ4YjQ0YjUwZDE1MzBjNzRjID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbMTMuMDI3MDE5OSwgNzcuNDk0MDk0XSwKICAgICAgICAgICAgICAgIHsiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsICJjb2xvciI6ICIjMDAwMDAwIiwgImRhc2hBcnJheSI6IG51bGwsICJkYXNoT2Zmc2V0IjogbnVsbCwgImZpbGwiOiB0cnVlLCAiZmlsbENvbG9yIjogIiNEM0QzRDMiLCAiZmlsbE9wYWNpdHkiOiAxLCAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsICJsaW5lQ2FwIjogInJvdW5kIiwgImxpbmVKb2luIjogInJvdW5kIiwgIm9wYWNpdHkiOiAxLjAsICJyYWRpdXMiOiA1LCAic3Ryb2tlIjogdHJ1ZSwgIndlaWdodCI6IDN9CiAgICAgICAgICAgICkuYWRkVG8obWFwXzYwYzJiZmUxNzM2MDQ4OGViZTkwOGVlY2Y5ZTQ4NmY4KTsKICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl8yOGY2ZmIyMTAxMTc0MTc1OWFkZDZlNTBjNzg3MGU1YyA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzE5LjE5MjA1NjAwMDAwMDAwNCwgNzIuOTU4NTE4OF0sCiAgICAgICAgICAgICAgICB7ImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLCAiY29sb3IiOiAiIzAwMDAwMCIsICJkYXNoQXJyYXkiOiBudWxsLCAiZGFzaE9mZnNldCI6IG51bGwsICJmaWxsIjogdHJ1ZSwgImZpbGxDb2xvciI6ICIjRDNEM0QzIiwgImZpbGxPcGFjaXR5IjogMSwgImZpbGxSdWxlIjogImV2ZW5vZGQiLCAibGluZUNhcCI6ICJyb3VuZCIsICJsaW5lSm9pbiI6ICJyb3VuZCIsICJvcGFjaXR5IjogMS4wLCAicmFkaXVzIjogNSwgInN0cm9rZSI6IHRydWUsICJ3ZWlnaHQiOiAzfQogICAgICAgICAgICApLmFkZFRvKG1hcF82MGMyYmZlMTczNjA0ODhlYmU5MDhlZWNmOWU0ODZmOCk7CiAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfYWYzMmJhZDM5YTY0NDMzMmJkMjU4MjY2MTNlYzIwM2YgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs4LjUxNDkwOTMwMDAwMDAwMSwgNzYuOTQzNTg3OTAwMDAwMDFdLAogICAgICAgICAgICAgICAgeyJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwgImNvbG9yIjogIiMwMDAwMDAiLCAiZGFzaEFycmF5IjogbnVsbCwgImRhc2hPZmZzZXQiOiBudWxsLCAiZmlsbCI6IHRydWUsICJmaWxsQ29sb3IiOiAiI0QzRDNEMyIsICJmaWxsT3BhY2l0eSI6IDEsICJmaWxsUnVsZSI6ICJldmVub2RkIiwgImxpbmVDYXAiOiAicm91bmQiLCAibGluZUpvaW4iOiAicm91bmQiLCAib3BhY2l0eSI6IDEuMCwgInJhZGl1cyI6IDUsICJzdHJva2UiOiB0cnVlLCAid2VpZ2h0IjogM30KICAgICAgICAgICAgKS5hZGRUbyhtYXBfNjBjMmJmZTE3MzYwNDg4ZWJlOTA4ZWVjZjllNDg2ZjgpOwogICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzkxN2U0MjI3ODU1MzQ0YmM4NWVhZmEwYzc4YjA4MWUxID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbMjYuOTE2NDA5MTk5OTk5OTkzLCA3NS43OTk0OTAwOTk5OTk5OV0sCiAgICAgICAgICAgICAgICB7ImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLCAiY29sb3IiOiAiIzAwMDAwMCIsICJkYXNoQXJyYXkiOiBudWxsLCAiZGFzaE9mZnNldCI6IG51bGwsICJmaWxsIjogdHJ1ZSwgImZpbGxDb2xvciI6ICIjRDNEM0QzIiwgImZpbGxPcGFjaXR5IjogMSwgImZpbGxSdWxlIjogImV2ZW5vZGQiLCAibGluZUNhcCI6ICJyb3VuZCIsICJsaW5lSm9pbiI6ICJyb3VuZCIsICJvcGFjaXR5IjogMS4wLCAicmFkaXVzIjogNSwgInN0cm9rZSI6IHRydWUsICJ3ZWlnaHQiOiAzfQogICAgICAgICAgICApLmFkZFRvKG1hcF82MGMyYmZlMTczNjA0ODhlYmU5MDhlZWNmOWU0ODZmOCk7CiAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfZDY4NjBhZWNmZGY1NDNjOGEyYTBhOTE0N2I3MmQ1ODcgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFszMC45MDI4MDAwMDAwMDAwMSwgNzUuODA4NTk5OTk5OTk5OThdLAogICAgICAgICAgICAgICAgeyJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwgImNvbG9yIjogIiMwMDAwMDAiLCAiZGFzaEFycmF5IjogbnVsbCwgImRhc2hPZmZzZXQiOiBudWxsLCAiZmlsbCI6IHRydWUsICJmaWxsQ29sb3IiOiAiI0QzRDNEMyIsICJmaWxsT3BhY2l0eSI6IDEsICJmaWxsUnVsZSI6ICJldmVub2RkIiwgImxpbmVDYXAiOiAicm91bmQiLCAibGluZUpvaW4iOiAicm91bmQiLCAib3BhY2l0eSI6IDEuMCwgInJhZGl1cyI6IDUsICJzdHJva2UiOiB0cnVlLCAid2VpZ2h0IjogM30KICAgICAgICAgICAgKS5hZGRUbyhtYXBfNjBjMmJmZTE3MzYwNDg4ZWJlOTA4ZWVjZjllNDg2ZjgpOwogICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyX2U5ZDM5ZTIwYWRiNzRiNDM5ZDhhODc0NzkxZDFjM2E3ID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbMjguNjEwMzAzOTk5OTk5OTksIDc3LjA5OTY5NDNdLAogICAgICAgICAgICAgICAgeyJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwgImNvbG9yIjogIiMwMDAwMDAiLCAiZGFzaEFycmF5IjogbnVsbCwgImRhc2hPZmZzZXQiOiBudWxsLCAiZmlsbCI6IHRydWUsICJmaWxsQ29sb3IiOiAiI0QzRDNEMyIsICJmaWxsT3BhY2l0eSI6IDEsICJmaWxsUnVsZSI6ICJldmVub2RkIiwgImxpbmVDYXAiOiAicm91bmQiLCAibGluZUpvaW4iOiAicm91bmQiLCAib3BhY2l0eSI6IDEuMCwgInJhZGl1cyI6IDUsICJzdHJva2UiOiB0cnVlLCAid2VpZ2h0IjogM30KICAgICAgICAgICAgKS5hZGRUbyhtYXBfNjBjMmJmZTE3MzYwNDg4ZWJlOTA4ZWVjZjllNDg2ZjgpOwogICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzFjZmRlOTNiNzA0NzQ2YWJhZTI1YzZiNDBmYWU2ZDUwID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbMjguNTY0NjEwMTk5OTk5OTk3LCA3Ny4xNjcwMTAzXSwKICAgICAgICAgICAgICAgIHsiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsICJjb2xvciI6ICIjMDAwMDAwIiwgImRhc2hBcnJheSI6IG51bGwsICJkYXNoT2Zmc2V0IjogbnVsbCwgImZpbGwiOiB0cnVlLCAiZmlsbENvbG9yIjogIiNEM0QzRDMiLCAiZmlsbE9wYWNpdHkiOiAxLCAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsICJsaW5lQ2FwIjogInJvdW5kIiwgImxpbmVKb2luIjogInJvdW5kIiwgIm9wYWNpdHkiOiAxLjAsICJyYWRpdXMiOiA1LCAic3Ryb2tlIjogdHJ1ZSwgIndlaWdodCI6IDN9CiAgICAgICAgICAgICkuYWRkVG8obWFwXzYwYzJiZmUxNzM2MDQ4OGViZTkwOGVlY2Y5ZTQ4NmY4KTsKICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl8yM2E3YjM5NzM2OGQ0OTZmODMxMmE1NWNhYzhlZGEyNyA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzI4LjE5NDkwOTAwMDAwMDAwMywgNzYuODYyMjk2XSwKICAgICAgICAgICAgICAgIHsiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsICJjb2xvciI6ICIjMDAwMDAwIiwgImRhc2hBcnJheSI6IG51bGwsICJkYXNoT2Zmc2V0IjogbnVsbCwgImZpbGwiOiB0cnVlLCAiZmlsbENvbG9yIjogIiNEM0QzRDMiLCAiZmlsbE9wYWNpdHkiOiAxLCAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsICJsaW5lQ2FwIjogInJvdW5kIiwgImxpbmVKb2luIjogInJvdW5kIiwgIm9wYWNpdHkiOiAxLjAsICJyYWRpdXMiOiA1LCAic3Ryb2tlIjogdHJ1ZSwgIndlaWdodCI6IDN9CiAgICAgICAgICAgICkuYWRkVG8obWFwXzYwYzJiZmUxNzM2MDQ4OGViZTkwOGVlY2Y5ZTQ4NmY4KTsKICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl81Mjc4MTU2MDQ1MTY0Y2E2ODU1OThhNWU3NDYwNGUyYiA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzMwLjY0OTk2MSwgNzYuMzMxNDQyMDAwMDAwMDJdLAogICAgICAgICAgICAgICAgeyJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwgImNvbG9yIjogIiMwMDAwMDAiLCAiZGFzaEFycmF5IjogbnVsbCwgImRhc2hPZmZzZXQiOiBudWxsLCAiZmlsbCI6IHRydWUsICJmaWxsQ29sb3IiOiAiI0QzRDNEMyIsICJmaWxsT3BhY2l0eSI6IDEsICJmaWxsUnVsZSI6ICJldmVub2RkIiwgImxpbmVDYXAiOiAicm91bmQiLCAibGluZUpvaW4iOiAicm91bmQiLCAib3BhY2l0eSI6IDEuMCwgInJhZGl1cyI6IDUsICJzdHJva2UiOiB0cnVlLCAid2VpZ2h0IjogM30KICAgICAgICAgICAgKS5hZGRUbyhtYXBfNjBjMmJmZTE3MzYwNDg4ZWJlOTA4ZWVjZjllNDg2ZjgpOwogICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyX2VmM2IwMzllMjExMjQ3ZGE5Yzg5ZDcwOWE3ZWM5ODE1ID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbMTcuNDU1OTQ1OCwgNzguNDMzMjE1MTk5OTk5OTldLAogICAgICAgICAgICAgICAgeyJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwgImNvbG9yIjogIiMwMDAwMDAiLCAiZGFzaEFycmF5IjogbnVsbCwgImRhc2hPZmZzZXQiOiBudWxsLCAiZmlsbCI6IHRydWUsICJmaWxsQ29sb3IiOiAiI0QzRDNEMyIsICJmaWxsT3BhY2l0eSI6IDEsICJmaWxsUnVsZSI6ICJldmVub2RkIiwgImxpbmVDYXAiOiAicm91bmQiLCAibGluZUpvaW4iOiAicm91bmQiLCAib3BhY2l0eSI6IDEuMCwgInJhZGl1cyI6IDUsICJzdHJva2UiOiB0cnVlLCAid2VpZ2h0IjogM30KICAgICAgICAgICAgKS5hZGRUbyhtYXBfNjBjMmJmZTE3MzYwNDg4ZWJlOTA4ZWVjZjllNDg2ZjgpOwogICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyX2I5MmE2NjU5YTVkZTQ4YjQ4NGY0ZjIyZjdmYmFhZWQzID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbMjcuMTk4NjU4MzMsIDc4LjAwNTk4MDU2XSwKICAgICAgICAgICAgICAgIHsiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsICJjb2xvciI6ICIjMDAwMDAwIiwgImRhc2hBcnJheSI6IG51bGwsICJkYXNoT2Zmc2V0IjogbnVsbCwgImZpbGwiOiB0cnVlLCAiZmlsbENvbG9yIjogIiNEM0QzRDMiLCAiZmlsbE9wYWNpdHkiOiAxLCAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsICJsaW5lQ2FwIjogInJvdW5kIiwgImxpbmVKb2luIjogInJvdW5kIiwgIm9wYWNpdHkiOiAxLjAsICJyYWRpdXMiOiA1LCAic3Ryb2tlIjogdHJ1ZSwgIndlaWdodCI6IDN9CiAgICAgICAgICAgICkuYWRkVG8obWFwXzYwYzJiZmUxNzM2MDQ4OGViZTkwOGVlY2Y5ZTQ4NmY4KTsKICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl8wMDMxNzEyOWJiNGQ0OGYyOGJmMDdjMWVjNjE1MjBlMSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzE2LjUxNTA4MzMsIDgwLjUxODE2NjddLAogICAgICAgICAgICAgICAgeyJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwgImNvbG9yIjogIiMwMDAwMDAiLCAiZGFzaEFycmF5IjogbnVsbCwgImRhc2hPZmZzZXQiOiBudWxsLCAiZmlsbCI6IHRydWUsICJmaWxsQ29sb3IiOiAiI0QzRDNEMyIsICJmaWxsT3BhY2l0eSI6IDEsICJmaWxsUnVsZSI6ICJldmVub2RkIiwgImxpbmVDYXAiOiAicm91bmQiLCAibGluZUpvaW4iOiAicm91bmQiLCAib3BhY2l0eSI6IDEuMCwgInJhZGl1cyI6IDUsICJzdHJva2UiOiB0cnVlLCAid2VpZ2h0IjogM30KICAgICAgICAgICAgKS5hZGRUbyhtYXBfNjBjMmJmZTE3MzYwNDg4ZWJlOTA4ZWVjZjllNDg2ZjgpOwogICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyX2YwYzdhOTU4MTJkMDQ1NDU5MzI1OGZkNzA4ODZhNjA1ID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbMjguNTQ0NzYwOCwgNzcuMzIzMTI1Njk5OTk5OTldLAogICAgICAgICAgICAgICAgeyJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwgImNvbG9yIjogIiMwMDAwMDAiLCAiZGFzaEFycmF5IjogbnVsbCwgImRhc2hPZmZzZXQiOiBudWxsLCAiZmlsbCI6IHRydWUsICJmaWxsQ29sb3IiOiAiI0QzRDNEMyIsICJmaWxsT3BhY2l0eSI6IDEsICJmaWxsUnVsZSI6ICJldmVub2RkIiwgImxpbmVDYXAiOiAicm91bmQiLCAibGluZUpvaW4iOiAicm91bmQiLCAib3BhY2l0eSI6IDEuMCwgInJhZGl1cyI6IDUsICJzdHJva2UiOiB0cnVlLCAid2VpZ2h0IjogM30KICAgICAgICAgICAgKS5hZGRUbyhtYXBfNjBjMmJmZTE3MzYwNDg4ZWJlOTA4ZWVjZjllNDg2ZjgpOwogICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzMxOTZmMzY1MGQ2ZjQ5MjFhNGEyNTRmMGEzMzlmNjEwID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbMjguNjI0NTQ3ODk5OTk5OTk2LCA3Ny4zNTc3MTAzOTk5OTk5OV0sCiAgICAgICAgICAgICAgICB7ImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLCAiY29sb3IiOiAiIzAwMDAwMCIsICJkYXNoQXJyYXkiOiBudWxsLCAiZGFzaE9mZnNldCI6IG51bGwsICJmaWxsIjogdHJ1ZSwgImZpbGxDb2xvciI6ICIjRDNEM0QzIiwgImZpbGxPcGFjaXR5IjogMSwgImZpbGxSdWxlIjogImV2ZW5vZGQiLCAibGluZUNhcCI6ICJyb3VuZCIsICJsaW5lSm9pbiI6ICJyb3VuZCIsICJvcGFjaXR5IjogMS4wLCAicmFkaXVzIjogNSwgInN0cm9rZSI6IHRydWUsICJ3ZWlnaHQiOiAzfQogICAgICAgICAgICApLmFkZFRvKG1hcF82MGMyYmZlMTczNjA0ODhlYmU5MDhlZWNmOWU0ODZmOCk7CiAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfOGNlOWMzZWMwZGE1NDBiODg0NGQ5OTNhODk2MDg4MTQgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFsyOC40MDg4NDIxMDAwMDAwMSwgNzcuMzA5OTA4MV0sCiAgICAgICAgICAgICAgICB7ImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLCAiY29sb3IiOiAiIzAwMDAwMCIsICJkYXNoQXJyYXkiOiBudWxsLCAiZGFzaE9mZnNldCI6IG51bGwsICJmaWxsIjogdHJ1ZSwgImZpbGxDb2xvciI6ICIjRDNEM0QzIiwgImZpbGxPcGFjaXR5IjogMSwgImZpbGxSdWxlIjogImV2ZW5vZGQiLCAibGluZUNhcCI6ICJyb3VuZCIsICJsaW5lSm9pbiI6ICJyb3VuZCIsICJvcGFjaXR5IjogMS4wLCAicmFkaXVzIjogNSwgInN0cm9rZSI6IHRydWUsICJ3ZWlnaHQiOiAzfQogICAgICAgICAgICApLmFkZFRvKG1hcF82MGMyYmZlMTczNjA0ODhlYmU5MDhlZWNmOWU0ODZmOCk7CiAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfYzcxMDY0MmE0ZGIzNGY1MGFmYmZiZGZmMTdjYTQxZGIgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFsyMi42MjQ3NTc5OTk5OTk5OTYsIDc1LjY3NTIzODAwMDAwMDAyXSwKICAgICAgICAgICAgICAgIHsiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsICJjb2xvciI6ICIjMDAwMDAwIiwgImRhc2hBcnJheSI6IG51bGwsICJkYXNoT2Zmc2V0IjogbnVsbCwgImZpbGwiOiB0cnVlLCAiZmlsbENvbG9yIjogIiNEM0QzRDMiLCAiZmlsbE9wYWNpdHkiOiAxLCAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsICJsaW5lQ2FwIjogInJvdW5kIiwgImxpbmVKb2luIjogInJvdW5kIiwgIm9wYWNpdHkiOiAxLjAsICJyYWRpdXMiOiA1LCAic3Ryb2tlIjogdHJ1ZSwgIndlaWdodCI6IDN9CiAgICAgICAgICAgICkuYWRkVG8obWFwXzYwYzJiZmUxNzM2MDQ4OGViZTkwOGVlY2Y5ZTQ4NmY4KTsKICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl83ZjRmNzdkNGNiYzY0NDQzODk1Y2I1MjMwMmI3NzZmMSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzMwLjcwNTc3NzgwMDAwMDAwMywgNzYuODUzMTgwNTU1NTU1NDhdLAogICAgICAgICAgICAgICAgeyJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwgImNvbG9yIjogIiMwMDAwMDAiLCAiZGFzaEFycmF5IjogbnVsbCwgImRhc2hPZmZzZXQiOiBudWxsLCAiZmlsbCI6IHRydWUsICJmaWxsQ29sb3IiOiAiI0QzRDNEMyIsICJmaWxsT3BhY2l0eSI6IDEsICJmaWxsUnVsZSI6ICJldmVub2RkIiwgImxpbmVDYXAiOiAicm91bmQiLCAibGluZUpvaW4iOiAicm91bmQiLCAib3BhY2l0eSI6IDEuMCwgInJhZGl1cyI6IDUsICJzdHJva2UiOiB0cnVlLCAid2VpZ2h0IjogM30KICAgICAgICAgICAgKS5hZGRUbyhtYXBfNjBjMmJmZTE3MzYwNDg4ZWJlOTA4ZWVjZjllNDg2ZjgpOwogICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzYwYzFiNDZjNmJmODQ1ODg4ZjdiMmFlZTNkOGNhOTkwID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbMjMuMTA4NDM5OTk5OTk5OTk4LCA3Ny41MTE0MjgwMDAwMDAwMV0sCiAgICAgICAgICAgICAgICB7ImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLCAiY29sb3IiOiAiIzAwMDAwMCIsICJkYXNoQXJyYXkiOiBudWxsLCAiZGFzaE9mZnNldCI6IG51bGwsICJmaWxsIjogdHJ1ZSwgImZpbGxDb2xvciI6ICIjRDNEM0QzIiwgImZpbGxPcGFjaXR5IjogMSwgImZpbGxSdWxlIjogImV2ZW5vZGQiLCAibGluZUNhcCI6ICJyb3VuZCIsICJsaW5lSm9pbiI6ICJyb3VuZCIsICJvcGFjaXR5IjogMS4wLCAicmFkaXVzIjogNSwgInN0cm9rZSI6IHRydWUsICJ3ZWlnaHQiOiAzfQogICAgICAgICAgICApLmFkZFRvKG1hcF82MGMyYmZlMTczNjA0ODhlYmU5MDhlZWNmOWU0ODZmOCk7CiAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfODlmNTYyYjI0NDNjNGRlNjg0ZjA2ODQ4Mjc5ZGFhOTggPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFsyOC42NTE0NzgxMDAwMDAwMDYsIDc3LjE0NzMxMDVdLAogICAgICAgICAgICAgICAgeyJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwgImNvbG9yIjogIiMwMDAwMDAiLCAiZGFzaEFycmF5IjogbnVsbCwgImRhc2hPZmZzZXQiOiBudWxsLCAiZmlsbCI6IHRydWUsICJmaWxsQ29sb3IiOiAiI0QzRDNEMyIsICJmaWxsT3BhY2l0eSI6IDEsICJmaWxsUnVsZSI6ICJldmVub2RkIiwgImxpbmVDYXAiOiAicm91bmQiLCAibGluZUpvaW4iOiAicm91bmQiLCAib3BhY2l0eSI6IDEuMCwgInJhZGl1cyI6IDUsICJzdHJva2UiOiB0cnVlLCAid2VpZ2h0IjogM30KICAgICAgICAgICAgKS5hZGRUbyhtYXBfNjBjMmJmZTE3MzYwNDg4ZWJlOTA4ZWVjZjllNDg2ZjgpOwogICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzc4MDE2OTQ4MmJjZDRhMTdhNDRkMWMxNzc3MDdiMDU5ID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbMjYuOTUwMjkyOTAwMDAwMDA0LCA3NS43MzA5NDMwMDAwMDAwMV0sCiAgICAgICAgICAgICAgICB7ImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLCAiY29sb3IiOiAiIzAwMDAwMCIsICJkYXNoQXJyYXkiOiBudWxsLCAiZGFzaE9mZnNldCI6IG51bGwsICJmaWxsIjogdHJ1ZSwgImZpbGxDb2xvciI6ICIjRDNEM0QzIiwgImZpbGxPcGFjaXR5IjogMSwgImZpbGxSdWxlIjogImV2ZW5vZGQiLCAibGluZUNhcCI6ICJyb3VuZCIsICJsaW5lSm9pbiI6ICJyb3VuZCIsICJvcGFjaXR5IjogMS4wLCAicmFkaXVzIjogNSwgInN0cm9rZSI6IHRydWUsICJ3ZWlnaHQiOiAzfQogICAgICAgICAgICApLmFkZFRvKG1hcF82MGMyYmZlMTczNjA0ODhlYmU5MDhlZWNmOWU0ODZmOCk7CiAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfMTVhNGNlMTRmMzMzNDkxNmJkYmExYWEzNTcwMWIyMTAgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFsyNS4xNDM4OSwgNzUuODIxMjU1OTk5OTk5OTldLAogICAgICAgICAgICAgICAgeyJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwgImNvbG9yIjogIiMwMDAwMDAiLCAiZGFzaEFycmF5IjogbnVsbCwgImRhc2hPZmZzZXQiOiBudWxsLCAiZmlsbCI6IHRydWUsICJmaWxsQ29sb3IiOiAiI0QzRDNEMyIsICJmaWxsT3BhY2l0eSI6IDEsICJmaWxsUnVsZSI6ICJldmVub2RkIiwgImxpbmVDYXAiOiAicm91bmQiLCAibGluZUpvaW4iOiAicm91bmQiLCAib3BhY2l0eSI6IDEuMCwgInJhZGl1cyI6IDUsICJzdHJva2UiOiB0cnVlLCAid2VpZ2h0IjogM30KICAgICAgICAgICAgKS5hZGRUbyhtYXBfNjBjMmJmZTE3MzYwNDg4ZWJlOTA4ZWVjZjllNDg2ZjgpOwogICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyX2IzNjViNzQ2NTNjZjQ4NzI5ZGQ3MDI2MWRiNjdkZTczID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbMjguNTUwNDI0OSwgNzcuMjE1OTM3NzAwMDAwMDFdLAogICAgICAgICAgICAgICAgeyJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwgImNvbG9yIjogIiMwMDAwMDAiLCAiZGFzaEFycmF5IjogbnVsbCwgImRhc2hPZmZzZXQiOiBudWxsLCAiZmlsbCI6IHRydWUsICJmaWxsQ29sb3IiOiAiI0QzRDNEMyIsICJmaWxsT3BhY2l0eSI6IDEsICJmaWxsUnVsZSI6ICJldmVub2RkIiwgImxpbmVDYXAiOiAicm91bmQiLCAibGluZUpvaW4iOiAicm91bmQiLCAib3BhY2l0eSI6IDEuMCwgInJhZGl1cyI6IDUsICJzdHJva2UiOiB0cnVlLCAid2VpZ2h0IjogM30KICAgICAgICAgICAgKS5hZGRUbyhtYXBfNjBjMmJmZTE3MzYwNDg4ZWJlOTA4ZWVjZjllNDg2ZjgpOwogICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzNkYmE1MDk2MDBhMjRiNjc4ZWZmN2UxMTcwMDljZjhhID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbMjYuODMzOTk3MjIwMDAwMDEsIDgwLjg5MTczNjA5OTk5OTk5XSwKICAgICAgICAgICAgICAgIHsiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsICJjb2xvciI6ICIjMDAwMDAwIiwgImRhc2hBcnJheSI6IG51bGwsICJkYXNoT2Zmc2V0IjogbnVsbCwgImZpbGwiOiB0cnVlLCAiZmlsbENvbG9yIjogIiNEM0QzRDMiLCAiZmlsbE9wYWNpdHkiOiAxLCAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsICJsaW5lQ2FwIjogInJvdW5kIiwgImxpbmVKb2luIjogInJvdW5kIiwgIm9wYWNpdHkiOiAxLjAsICJyYWRpdXMiOiA1LCAic3Ryb2tlIjogdHJ1ZSwgIndlaWdodCI6IDN9CiAgICAgICAgICAgICkuYWRkVG8obWFwXzYwYzJiZmUxNzM2MDQ4OGViZTkwOGVlY2Y5ZTQ4NmY4KTsKICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9hYzExZmEwYzkzOTk0ZTE2ODVkYWNjMzJhZWNlMGRmNyA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzEzLjY2OTk5OTk5OTk5OTk5NiwgNzkuMzUwMDAwMDAwMDAwMDFdLAogICAgICAgICAgICAgICAgeyJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwgImNvbG9yIjogIiMwMDAwMDAiLCAiZGFzaEFycmF5IjogbnVsbCwgImRhc2hPZmZzZXQiOiBudWxsLCAiZmlsbCI6IHRydWUsICJmaWxsQ29sb3IiOiAiI0QzRDNEMyIsICJmaWxsT3BhY2l0eSI6IDEsICJmaWxsUnVsZSI6ICJldmVub2RkIiwgImxpbmVDYXAiOiAicm91bmQiLCAibGluZUpvaW4iOiAicm91bmQiLCAib3BhY2l0eSI6IDEuMCwgInJhZGl1cyI6IDUsICJzdHJva2UiOiB0cnVlLCAid2VpZ2h0IjogM30KICAgICAgICAgICAgKS5hZGRUbyhtYXBfNjBjMmJmZTE3MzYwNDg4ZWJlOTA4ZWVjZjllNDg2ZjgpOwogICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzRkYjk5NTk1MWFlMTRkNTE5ZWYzZjU2ZTU2MDQ5MzEyID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbMTMuMDg3ODQwMDAwMDAwMDA1LCA4MC4yNzg0Njk5OTk5OTk5OF0sCiAgICAgICAgICAgICAgICB7ImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLCAiY29sb3IiOiAiIzAwMDAwMCIsICJkYXNoQXJyYXkiOiBudWxsLCAiZGFzaE9mZnNldCI6IG51bGwsICJmaWxsIjogdHJ1ZSwgImZpbGxDb2xvciI6ICIjRDNEM0QzIiwgImZpbGxPcGFjaXR5IjogMSwgImZpbGxSdWxlIjogImV2ZW5vZGQiLCAibGluZUNhcCI6ICJyb3VuZCIsICJsaW5lSm9pbiI6ICJyb3VuZCIsICJvcGFjaXR5IjogMS4wLCAicmFkaXVzIjogNSwgInN0cm9rZSI6IHRydWUsICJ3ZWlnaHQiOiAzfQogICAgICAgICAgICApLmFkZFRvKG1hcF82MGMyYmZlMTczNjA0ODhlYmU5MDhlZWNmOWU0ODZmOCk7CiAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfOGI4MWY2MmNmYWRhNGEwOWFkODA1ZTA2NGNjYmJkMmQgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFsxNy4zODQwNSwgNzguNDU2MzU5OTk5OTk5OTZdLAogICAgICAgICAgICAgICAgeyJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwgImNvbG9yIjogIiMwMDAwMDAiLCAiZGFzaEFycmF5IjogbnVsbCwgImRhc2hPZmZzZXQiOiBudWxsLCAiZmlsbCI6IHRydWUsICJmaWxsQ29sb3IiOiAiI0QzRDNEMyIsICJmaWxsT3BhY2l0eSI6IDEsICJmaWxsUnVsZSI6ICJldmVub2RkIiwgImxpbmVDYXAiOiAicm91bmQiLCAibGluZUpvaW4iOiAicm91bmQiLCAib3BhY2l0eSI6IDEuMCwgInJhZGl1cyI6IDUsICJzdHJva2UiOiB0cnVlLCAid2VpZ2h0IjogM30KICAgICAgICAgICAgKS5hZGRUbyhtYXBfNjBjMmJmZTE3MzYwNDg4ZWJlOTA4ZWVjZjllNDg2ZjgpOwogICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzMxYjcyZTAxOGU3ZTQxYjA4NTE3YjU4ODIxYmRkNjExID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbMjIuNTYyNjMwMDAwMDAwMDEsIDg4LjM2MzAzOTk5OTk5OTk3XSwKICAgICAgICAgICAgICAgIHsiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsICJjb2xvciI6ICIjMDAwMDAwIiwgImRhc2hBcnJheSI6IG51bGwsICJkYXNoT2Zmc2V0IjogbnVsbCwgImZpbGwiOiB0cnVlLCAiZmlsbENvbG9yIjogIiNEM0QzRDMiLCAiZmlsbE9wYWNpdHkiOiAxLCAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsICJsaW5lQ2FwIjogInJvdW5kIiwgImxpbmVKb2luIjogInJvdW5kIiwgIm9wYWNpdHkiOiAxLjAsICJyYWRpdXMiOiA1LCAic3Ryb2tlIjogdHJ1ZSwgIndlaWdodCI6IDN9CiAgICAgICAgICAgICkuYWRkVG8obWFwXzYwYzJiZmUxNzM2MDQ4OGViZTkwOGVlY2Y5ZTQ4NmY4KTsKICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl83ZDgwNWRiNTgyNDc0YTVkYTM2YmNhYWFmM2NhN2Q2OSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzE5LjA3MjgzMDAwMDAwMDAwNywgNzIuODgyNjEwMDAwMDAwMDRdLAogICAgICAgICAgICAgICAgeyJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwgImNvbG9yIjogIiMwMDAwMDAiLCAiZGFzaEFycmF5IjogbnVsbCwgImRhc2hPZmZzZXQiOiBudWxsLCAiZmlsbCI6IHRydWUsICJmaWxsQ29sb3IiOiAiI0QzRDNEMyIsICJmaWxsT3BhY2l0eSI6IDEsICJmaWxsUnVsZSI6ICJldmVub2RkIiwgImxpbmVDYXAiOiAicm91bmQiLCAibGluZUpvaW4iOiAicm91bmQiLCAib3BhY2l0eSI6IDEuMCwgInJhZGl1cyI6IDUsICJzdHJva2UiOiB0cnVlLCAid2VpZ2h0IjogM30KICAgICAgICAgICAgKS5hZGRUbyhtYXBfNjBjMmJmZTE3MzYwNDg4ZWJlOTA4ZWVjZjllNDg2ZjgpOwogICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyX2Q3MWM5MzJlNzQyYjQxNmI5MzE5ZTM5ODZkMWEwNWM4ID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbMjguNjM1NzYsIDc3LjIyNDQ0OTk5OTk5OTk4XSwKICAgICAgICAgICAgICAgIHsiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsICJjb2xvciI6ICIjMDAwMDAwIiwgImRhc2hBcnJheSI6IG51bGwsICJkYXNoT2Zmc2V0IjogbnVsbCwgImZpbGwiOiB0cnVlLCAiZmlsbENvbG9yIjogIiNEM0QzRDMiLCAiZmlsbE9wYWNpdHkiOiAxLCAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsICJsaW5lQ2FwIjogInJvdW5kIiwgImxpbmVKb2luIjogInJvdW5kIiwgIm9wYWNpdHkiOiAxLjAsICJyYWRpdXMiOiA1LCAic3Ryb2tlIjogdHJ1ZSwgIndlaWdodCI6IDN9CiAgICAgICAgICAgICkuYWRkVG8obWFwXzYwYzJiZmUxNzM2MDQ4OGViZTkwOGVlY2Y5ZTQ4NmY4KTsKICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl80MjJmOTJjYjU3NTY0NTcyODNmZTRlMzEyYzk2NTQzMSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzI4LjY2MDMzNDYwMDAwMDAwMiwgNzcuMzU3MjU2M10sCiAgICAgICAgICAgICAgICB7ImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLCAiY29sb3IiOiAiIzAwMDAwMCIsICJkYXNoQXJyYXkiOiBudWxsLCAiZGFzaE9mZnNldCI6IG51bGwsICJmaWxsIjogdHJ1ZSwgImZpbGxDb2xvciI6ICIjRDNEM0QzIiwgImZpbGxPcGFjaXR5IjogMSwgImZpbGxSdWxlIjogImV2ZW5vZGQiLCAibGluZUNhcCI6ICJyb3VuZCIsICJsaW5lSm9pbiI6ICJyb3VuZCIsICJvcGFjaXR5IjogMS4wLCAicmFkaXVzIjogNSwgInN0cm9rZSI6IHRydWUsICJ3ZWlnaHQiOiAzfQogICAgICAgICAgICApLmFkZFRvKG1hcF82MGMyYmZlMTczNjA0ODhlYmU5MDhlZWNmOWU0ODZmOCk7CiAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfYWM2ZTY1ZWYwM2RhNGE5MTk5ZDIxMzE5MTY1YjZjNTMgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFsyOC40NTAxMjM4MDAwMDAwMSwgNzcuMDI2MzA1MDk5OTk5OTldLAogICAgICAgICAgICAgICAgeyJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwgImNvbG9yIjogIiMwMDAwMDAiLCAiZGFzaEFycmF5IjogbnVsbCwgImRhc2hPZmZzZXQiOiBudWxsLCAiZmlsbCI6IHRydWUsICJmaWxsQ29sb3IiOiAiI0QzRDNEMyIsICJmaWxsT3BhY2l0eSI6IDEsICJmaWxsUnVsZSI6ICJldmVub2RkIiwgImxpbmVDYXAiOiAicm91bmQiLCAibGluZUpvaW4iOiAicm91bmQiLCAib3BhY2l0eSI6IDEuMCwgInJhZGl1cyI6IDUsICJzdHJva2UiOiB0cnVlLCAid2VpZ2h0IjogM30KICAgICAgICAgICAgKS5hZGRUbyhtYXBfNjBjMmJmZTE3MzYwNDg4ZWJlOTA4ZWVjZjllNDg2ZjgpOwogICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzIwZDI1MThkZWFlNTRjZDQ4YmY0NTIwNDA3MjA1MTQwID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbMjQuMTA4OTcwMDAwMDAwMDAzLCA4Mi42NDU1ODAwMDAwMDAwMV0sCiAgICAgICAgICAgICAgICB7ImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLCAiY29sb3IiOiAiIzAwMDAwMCIsICJkYXNoQXJyYXkiOiBudWxsLCAiZGFzaE9mZnNldCI6IG51bGwsICJmaWxsIjogdHJ1ZSwgImZpbGxDb2xvciI6ICIjRDNEM0QzIiwgImZpbGxPcGFjaXR5IjogMSwgImZpbGxSdWxlIjogImV2ZW5vZGQiLCAibGluZUNhcCI6ICJyb3VuZCIsICJsaW5lSm9pbiI6ICJyb3VuZCIsICJvcGFjaXR5IjogMS4wLCAicmFkaXVzIjogNSwgInN0cm9rZSI6IHRydWUsICJ3ZWlnaHQiOiAzfQogICAgICAgICAgICApLmFkZFRvKG1hcF82MGMyYmZlMTczNjA0ODhlYmU5MDhlZWNmOWU0ODZmOCk7CiAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfZDU2OTNhOWIyMTgwNGJjOWJhMDdhN2E5N2MzZDVmMTAgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFsyNi42ODgzMDQ4OTk5OTk5OTUsIDg4LjQxMjY2ODAwMDAwMDA0XSwKICAgICAgICAgICAgICAgIHsiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsICJjb2xvciI6ICIjMDAwMDAwIiwgImRhc2hBcnJheSI6IG51bGwsICJkYXNoT2Zmc2V0IjogbnVsbCwgImZpbGwiOiB0cnVlLCAiZmlsbENvbG9yIjogIiNEM0QzRDMiLCAiZmlsbE9wYWNpdHkiOiAxLCAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsICJsaW5lQ2FwIjogInJvdW5kIiwgImxpbmVKb2luIjogInJvdW5kIiwgIm9wYWNpdHkiOiAxLjAsICJyYWRpdXMiOiA1LCAic3Ryb2tlIjogdHJ1ZSwgIndlaWdodCI6IDN9CiAgICAgICAgICAgICkuYWRkVG8obWFwXzYwYzJiZmUxNzM2MDQ4OGViZTkwOGVlY2Y5ZTQ4NmY4KTsKICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9iMTY0MTNlMTkzOTE0Y2Q5YjIwMTBjYjhjMzVkZGQ0MyA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzE3LjM0OTY5NCwgNzguNDUxNDM2OTk5OTk5OThdLAogICAgICAgICAgICAgICAgeyJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwgImNvbG9yIjogIiMwMDAwMDAiLCAiZGFzaEFycmF5IjogbnVsbCwgImRhc2hPZmZzZXQiOiBudWxsLCAiZmlsbCI6IHRydWUsICJmaWxsQ29sb3IiOiAiI0QzRDNEMyIsICJmaWxsT3BhY2l0eSI6IDEsICJmaWxsUnVsZSI6ICJldmVub2RkIiwgImxpbmVDYXAiOiAicm91bmQiLCAibGluZUpvaW4iOiAicm91bmQiLCAib3BhY2l0eSI6IDEuMCwgInJhZGl1cyI6IDUsICJzdHJva2UiOiB0cnVlLCAid2VpZ2h0IjogM30KICAgICAgICAgICAgKS5hZGRUbyhtYXBfNjBjMmJmZTE3MzYwNDg4ZWJlOTA4ZWVjZjllNDg2ZjgpOwogICAgICAgIAogICAgCiAgICAgICAgZnVuY3Rpb24gZ2VvX2pzb25fMzYxN2ZlMDcyZjZmNDhhZmFhMDhkOGFiYWYxMDY4NTVfb25FYWNoRmVhdHVyZShmZWF0dXJlLCBsYXllcikgewogICAgICAgICAgICBsYXllci5vbih7CiAgICAgICAgICAgICAgICBjbGljazogZnVuY3Rpb24oZSkgewogICAgICAgICAgICAgICAgICAgIG1hcF82MGMyYmZlMTczNjA0ODhlYmU5MDhlZWNmOWU0ODZmOC5maXRCb3VuZHMoZS50YXJnZXQuZ2V0Qm91bmRzKCkpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9KTsKICAgICAgICB9OwogICAgICAgIHZhciBnZW9fanNvbl8zNjE3ZmUwNzJmNmY0OGFmYWEwOGQ4YWJhZjEwNjg1NSA9IEwuZ2VvSnNvbihudWxsLCB7CiAgICAgICAgICAgICAgICBvbkVhY2hGZWF0dXJlOiBnZW9fanNvbl8zNjE3ZmUwNzJmNmY0OGFmYWEwOGQ4YWJhZjEwNjg1NV9vbkVhY2hGZWF0dXJlLAogICAgICAgICAgICAKICAgICAgICB9KTsKICAgICAgICBmdW5jdGlvbiBnZW9fanNvbl8zNjE3ZmUwNzJmNmY0OGFmYWEwOGQ4YWJhZjEwNjg1NV9hZGQgKGRhdGEpIHsKICAgICAgICAgICAgZ2VvX2pzb25fMzYxN2ZlMDcyZjZmNDhhZmFhMDhkOGFiYWYxMDY4NTUuYWRkRGF0YShkYXRhKQogICAgICAgICAgICAgICAgLmFkZFRvKG1hcF82MGMyYmZlMTczNjA0ODhlYmU5MDhlZWNmOWU0ODZmOCk7CiAgICAgICAgfQogICAgICAgICAgICBnZW9fanNvbl8zNjE3ZmUwNzJmNmY0OGFmYWEwOGQ4YWJhZjEwNjg1NV9hZGQoeyJnZW9tZXRyeSI6IHsiY29vcmRpbmF0ZXMiOiBbW1s3Ny44Mzc0NTEsIDM1LjQ5NDAxXSwgWzc4LjkxMjI2OSwgMzQuMzIxOTM2XSwgWzc4LjgxMTA4NiwgMzMuNTA2MTk4XSwgWzc5LjIwODg5MiwgMzIuOTk0Mzk1XSwgWzc5LjE3NjEyOSwgMzIuNDgzNzhdLCBbNzguNDU4NDQ2LCAzMi42MTgxNjRdLCBbNzguNzM4ODk0LCAzMS41MTU5MDZdLCBbNzkuNzIxMzY3LCAzMC44ODI3MTVdLCBbODEuMTExMjU2LCAzMC4xODM0ODFdLCBbODAuNDc2NzIxLCAyOS43Mjk4NjVdLCBbODAuMDg4NDI1LCAyOC43OTQ0N10sIFs4MS4wNTcyMDMsIDI4LjQxNjA5NV0sIFs4MS45OTk5ODcsIDI3LjkyNTQ3OV0sIFs4My4zMDQyNDksIDI3LjM2NDUwNl0sIFs4NC42NzUwMTgsIDI3LjIzNDkwMV0sIFs4NS4yNTE3NzksIDI2LjcyNjE5OF0sIFs4Ni4wMjQzOTMsIDI2LjYzMDk4NV0sIFs4Ny4yMjc0NzIsIDI2LjM5Nzg5OF0sIFs4OC4wNjAyMzgsIDI2LjQxNDYxNV0sIFs4OC4xNzQ4MDQsIDI2LjgxMDQwNV0sIFs4OC4wNDMxMzMsIDI3LjQ0NTgxOV0sIFs4OC4xMjA0NDEsIDI3Ljg3NjU0Ml0sIFs4OC43MzAzMjYsIDI4LjA4Njg2NV0sIFs4OC44MTQyNDgsIDI3LjI5OTMxNl0sIFs4OC44MzU2NDMsIDI3LjA5ODk2Nl0sIFs4OS43NDQ1MjgsIDI2LjcxOTQwM10sIFs5MC4zNzMyNzUsIDI2Ljg3NTcyNF0sIFs5MS4yMTc1MTMsIDI2LjgwODY0OF0sIFs5Mi4wMzM0ODQsIDI2LjgzODMxXSwgWzkyLjEwMzcxMiwgMjcuNDUyNjE0XSwgWzkxLjY5NjY1NywgMjcuNzcxNzQyXSwgWzkyLjUwMzExOSwgMjcuODk2ODc2XSwgWzkzLjQxMzM0OCwgMjguNjQwNjI5XSwgWzk0LjU2NTk5LCAyOS4yNzc0MzhdLCBbOTUuNDA0ODAyLCAyOS4wMzE3MTddLCBbOTYuMTE3Njc5LCAyOS40NTI4MDJdLCBbOTYuNTg2NTkxLCAyOC44MzA5OF0sIFs5Ni4yNDg4MzMsIDI4LjQxMTAzMV0sIFs5Ny4zMjcxMTQsIDI4LjI2MTU4M10sIFs5Ny40MDI1NjEsIDI3Ljg4MjUzNl0sIFs5Ny4wNTE5ODksIDI3LjY5OTA1OV0sIFs5Ny4xMzM5OTksIDI3LjA4Mzc3NF0sIFs5Ni40MTkzNjYsIDI3LjI2NDU4OV0sIFs5NS4xMjQ3NjgsIDI2LjU3MzU3Ml0sIFs5NS4xNTUxNTMsIDI2LjAwMTMwN10sIFs5NC42MDMyNDksIDI1LjE2MjQ5NV0sIFs5NC41NTI2NTgsIDI0LjY3NTIzOF0sIFs5NC4xMDY3NDIsIDIzLjg1MDc0MV0sIFs5My4zMjUxODgsIDI0LjA3ODU1Nl0sIFs5My4yODYzMjcsIDIzLjA0MzY1OF0sIFs5My4wNjAyOTQsIDIyLjcwMzExMV0sIFs5My4xNjYxMjgsIDIyLjI3ODQ2XSwgWzkyLjY3MjcyMSwgMjIuMDQxMjM5XSwgWzkyLjE0NjAzNSwgMjMuNjI3NDk5XSwgWzkxLjg2OTkyOCwgMjMuNjI0MzQ2XSwgWzkxLjcwNjQ3NSwgMjIuOTg1MjY0XSwgWzkxLjE1ODk2MywgMjMuNTAzNTI3XSwgWzkxLjQ2NzczLCAyNC4wNzI2MzldLCBbOTEuOTE1MDkzLCAyNC4xMzA0MTRdLCBbOTIuMzc2MjAyLCAyNC45NzY2OTNdLCBbOTEuNzk5NTk2LCAyNS4xNDc0MzJdLCBbOTAuODcyMjExLCAyNS4xMzI2MDFdLCBbODkuOTIwNjkzLCAyNS4yNjk3NV0sIFs4OS44MzI0ODEsIDI1Ljk2NTA4Ml0sIFs4OS4zNTUwOTQsIDI2LjAxNDQwN10sIFs4OC41NjMwNDksIDI2LjQ0NjUyNl0sIFs4OC4yMDk3ODksIDI1Ljc2ODA2Nl0sIFs4OC45MzE1NTQsIDI1LjIzODY5Ml0sIFs4OC4zMDYzNzMsIDI0Ljg2NjA3OV0sIFs4OC4wODQ0MjIsIDI0LjUwMTY1N10sIFs4OC42OTk5NCwgMjQuMjMzNzE1XSwgWzg4LjUyOTc3LCAyMy42MzExNDJdLCBbODguODc2MzEyLCAyMi44NzkxNDZdLCBbODkuMDMxOTYxLCAyMi4wNTU3MDhdLCBbODguODg4NzY2LCAyMS42OTA1ODhdLCBbODguMjA4NDk3LCAyMS43MDMxNzJdLCBbODYuOTc1NzA0LCAyMS40OTU1NjJdLCBbODcuMDMzMTY5LCAyMC43NDMzMDhdLCBbODYuNDk5MzUxLCAyMC4xNTE2MzhdLCBbODUuMDYwMjY2LCAxOS40Nzg1NzldLCBbODMuOTQxMDA2LCAxOC4zMDIwMV0sIFs4My4xODkyMTcsIDE3LjY3MTIyMV0sIFs4Mi4xOTI3OTIsIDE3LjAxNjYzNl0sIFs4Mi4xOTEyNDIsIDE2LjU1NjY2NF0sIFs4MS42OTI3MTksIDE2LjMxMDIxOV0sIFs4MC43OTE5OTksIDE1Ljk1MTk3Ml0sIFs4MC4zMjQ4OTYsIDE1Ljg5OTE4NV0sIFs4MC4wMjUwNjksIDE1LjEzNjQxNV0sIFs4MC4yMzMyNzQsIDEzLjgzNTc3MV0sIFs4MC4yODYyOTQsIDEzLjAwNjI2MV0sIFs3OS44NjI1NDcsIDEyLjA1NjIxNV0sIFs3OS44NTc5OTksIDEwLjM1NzI3NV0sIFs3OS4zNDA1MTIsIDEwLjMwODg1NF0sIFs3OC44ODUzNDUsIDkuNTQ2MTM2XSwgWzc5LjE4OTcyLCA5LjIxNjU0NF0sIFs3OC4yNzc5NDEsIDguOTMzMDQ3XSwgWzc3Ljk0MTE2NSwgOC4yNTI5NTldLCBbNzcuNTM5ODk4LCA3Ljk2NTUzNV0sIFs3Ni41OTI5NzksIDguODk5Mjc2XSwgWzc2LjEzMDA2MSwgMTAuMjk5NjNdLCBbNzUuNzQ2NDY3LCAxMS4zMDgyNTFdLCBbNzUuMzk2MTAxLCAxMS43ODEyNDVdLCBbNzQuODY0ODE2LCAxMi43NDE5MzZdLCBbNzQuNjE2NzE3LCAxMy45OTI1ODNdLCBbNzQuNDQzODU5LCAxNC42MTcyMjJdLCBbNzMuNTM0MTk5LCAxNS45OTA2NTJdLCBbNzMuMTE5OTA5LCAxNy45Mjg1N10sIFs3Mi44MjA5MDksIDE5LjIwODIzNF0sIFs3Mi44MjQ0NzUsIDIwLjQxOTUwM10sIFs3Mi42MzA1MzMsIDIxLjM1NjAwOV0sIFs3MS4xNzUyNzMsIDIwLjc1NzQ0MV0sIFs3MC40NzA0NTksIDIwLjg3NzMzMV0sIFs2OS4xNjQxMywgMjIuMDg5Mjk4XSwgWzY5LjY0NDkyOCwgMjIuNDUwNzc1XSwgWzY5LjM0OTU5NywgMjIuODQzMThdLCBbNjguMTc2NjQ1LCAyMy42OTE5NjVdLCBbNjguODQyNTk5LCAyNC4zNTkxMzRdLCBbNzEuMDQzMjQsIDI0LjM1NjUyNF0sIFs3MC44NDQ2OTksIDI1LjIxNTEwMl0sIFs3MC4yODI4NzMsIDI1LjcyMjIyOV0sIFs3MC4xNjg5MjcsIDI2LjQ5MTg3Ml0sIFs2OS41MTQzOTMsIDI2Ljk0MDk2Nl0sIFs3MC42MTY0OTYsIDI3Ljk4OTE5Nl0sIFs3MS43Nzc2NjYsIDI3LjkxMzE4XSwgWzcyLjgyMzc1MiwgMjguOTYxNTkyXSwgWzczLjQ1MDYzOCwgMjkuOTc2NDEzXSwgWzc0LjQyMTM4LCAzMC45Nzk4MTVdLCBbNzQuNDA1OTI5LCAzMS42OTI2MzldLCBbNzUuMjU4NjQyLCAzMi4yNzExMDVdLCBbNzQuNDUxNTU5LCAzMi43NjQ5XSwgWzc0LjEwNDI5NCwgMzMuNDQxNDczXSwgWzczLjc0OTk0OCwgMzQuMzE3Njk5XSwgWzc0LjI0MDIwMywgMzQuNzQ4ODg3XSwgWzc1Ljc1NzA2MSwgMzQuNTA0OTIzXSwgWzc2Ljg3MTcyMiwgMzQuNjUzNTQ0XSwgWzc3LjgzNzQ1MSwgMzUuNDk0MDFdXV0sICJ0eXBlIjogIlBvbHlnb24ifSwgImlkIjogIklORCIsICJwcm9wZXJ0aWVzIjogeyJuYW1lIjogIkluZGlhIn0sICJ0eXBlIjogIkZlYXR1cmUifSk7CiAgICAgICAgCjwvc2NyaXB0Pg== onload= this. contentDocument. open();this. contentDocument. write(atob(this. getAttribute('data-html')));this. contentDocument. close();  allowfullscreen webkitallowfullscreen mozallowfullscreen&gt;&lt;/iframe&gt;        folium_map. save(&quot;map. html&quot;)          import osimport timefrom selenium import webdriverdelay=5fn=&#39;map. html&#39;tmpurl=&#39;file://{path}/{mapfile}&#39;. format(path=os. getcwd(),mapfile=fn)browser = webdriver. Firefox()browser. get(tmpurl)#Give the map tiles some time to loadtime. sleep(delay)browser. save_screenshot(&#39;map. png&#39;)browser. quit()  ---------------------------------------------------------------------------FileNotFoundError             Traceback (most recent call last)~/anaconda3/lib/python3. 7/site-packages/selenium/webdriver/common/service. py in start(self)   75                       stderr=self. log_file,---&gt; 76                       stdin=PIPE)   77     except TypeError:~/anaconda3/lib/python3. 7/subprocess. py in __init__(self, args, bufsize, executable, stdin, stdout, stderr, preexec_fn, close_fds, shell, cwd, env, universal_newlines, startupinfo, creationflags, restore_signals, start_new_session, pass_fds, encoding, errors, text)  774                 errread, errwrite,--&gt; 775                 restore_signals, start_new_session)  776     except:~/anaconda3/lib/python3. 7/subprocess. py in _execute_child(self, args, executable, preexec_fn, close_fds, pass_fds, cwd, env, startupinfo, creationflags, shell, p2cread, p2cwrite, c2pread, c2pwrite, errread, errwrite, restore_signals, start_new_session)  1521               err_msg += &#39;: &#39; + repr(err_filename)-&gt; 1522           raise child_exception_type(errno_num, err_msg, err_filename)  1523         raise child_exception_type(err_msg)FileNotFoundError: [Errno 2] No such file or directory: &#39;geckodriver&#39;: &#39;geckodriver&#39;During handling of the above exception, another exception occurred:WebDriverException            Traceback (most recent call last)&lt;ipython-input-11-8762ed45da53&gt; in &lt;module&gt;   7 tmpurl=&#39;file://{path}/{mapfile}&#39;. format(path=os. getcwd(),mapfile=fn)   8 ----&gt; 9 browser = webdriver. Firefox()   10 browser. get(tmpurl)   11 #Give the map tiles some time to load~/anaconda3/lib/python3. 7/site-packages/selenium/webdriver/firefox/webdriver. py in __init__(self, firefox_profile, firefox_binary, timeout, capabilities, proxy, executable_path, options, service_log_path, firefox_options, service_args, desired_capabilities, log_path, keep_alive)  162         service_args=service_args,  163         log_path=service_log_path)--&gt; 164       self. service. start()  165   166       capabilities. update(options. to_capabilities())~/anaconda3/lib/python3. 7/site-packages/selenium/webdriver/common/service. py in start(self)   81         raise WebDriverException(   82           &#34;&#39;%s&#39; executable needs to be in PATH. %s&#34; % (---&gt; 83             os. path. basename(self. path), self. start_error_message)   84         )   85       elif err. errno == errno. EACCES:WebDriverException: Message: &#39;geckodriver&#39; executable needs to be in PATH.   There you go! "
    }];

var idx = lunr(function () {
    this.ref('id')
    this.field('title')
    this.field('body')
    this.metadataWhitelist = ['position']

    documents.forEach(function (doc) {
        this.add(doc)
    }, this)
});
function lunr_search(term) {
    document.getElementById('lunrsearchresults').innerHTML = '<ul></ul>';
    if(term) {
        document.getElementById('lunrsearchresults').innerHTML = "<p>Search results for '" + term + "'</p>" + document.getElementById('lunrsearchresults').innerHTML;
        //put results on the screen.
        var results = idx.search(term);
        if(results.length>0){
            //console.log(idx.search(term));
            //if results
            for (var i = 0; i < results.length; i++) {
                // more statements
                var ref = results[i]['ref'];
                var url = documents[ref]['url'];
                var title = documents[ref]['title'];
                var body = documents[ref]['body'].substring(0,160)+'...';
                document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML = document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML + "<li class='lunrsearchresult'><a href='" + url + "'><span class='title'>" + title + "</span><br /><span class='body'>"+ body +"</span><br /><span class='url'>"+ url +"</span></a></li>";
            }
        } else {
            document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML = "<li class='lunrsearchresult'>No results found...</li>";
        }
    }
    return false;
}